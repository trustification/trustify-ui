import React from "react";

import { VulnerabilityStatus } from "@app/api/models";
import {
  PurlSummary,
  VulnerabilityAdvisorySummary,
  VulnerabilitySbomStatus,
} from "@app/client";
import { useFetchVulnerabilityById } from "@app/queries/vulnerabilities";

const areSbomOfVulnerabilityEqual = (
  a: SbomOfVulnerability,
  b: SbomOfVulnerability | FlatSbomOfVulnerability
) => {
  return a.sbom.id === b.sbom.id && a.sbomStatus === b.sbomStatus;
};

interface FlatSbomOfVulnerability {
  sbom: VulnerabilitySbomStatus;
  sbomStatus: VulnerabilityStatus;
  advisory: VulnerabilityAdvisorySummary;
  packages: PurlSummary[];
}

interface SbomOfVulnerability {
  sbom: VulnerabilitySbomStatus;
  sbomStatus: VulnerabilityStatus;
  relatedPackages: {
    advisory: VulnerabilityAdvisorySummary;
    packages: PurlSummary[];
  }[];
}

export interface SbomOfVulnerabilitySummary {
  total: number;
  sbomStatus: { [key in VulnerabilityStatus]: number };
}

const DEFAULT_SUMMARY: SbomOfVulnerabilitySummary = {
  total: 0,
  sbomStatus: { affected: 0, fixed: 0, known_not_affected: 0, not_affected: 0 },
};

const advisoryToModels = (advisories: VulnerabilityAdvisorySummary[]) => {
  const sboms = advisories.flatMap((advisory) => {
    return (
      (advisory.sboms ?? [])
        .flatMap((sbomStatuses) => {
          return Object.entries(sbomStatuses.purl_statuses || {}).map(
            ([status, packages]) => {
              const result: FlatSbomOfVulnerability = {
                sbom: {
                  ...sbomStatuses,
                },
                sbomStatus: status as VulnerabilityStatus,
                advisory: advisory,
                packages: packages,
              };
              return result;
            }
          );
        })
        // group
        .reduce((prev, current) => {
          const existingElement = prev.find((item) => {
            return areSbomOfVulnerabilityEqual(item, current);
          });

          if (existingElement) {
            const arrayWithoutExistingItem = prev.filter(
              (item) => !areSbomOfVulnerabilityEqual(item, existingElement)
            );

            const updatedItemInArray: SbomOfVulnerability = {
              ...existingElement,
              relatedPackages: [
                ...existingElement.relatedPackages,
                {
                  advisory: current.advisory,
                  packages: current.packages,
                },
              ],
            };

            return [...arrayWithoutExistingItem, updatedItemInArray];
          } else {
            const newItemInArray: SbomOfVulnerability = {
              sbom: current.sbom,
              sbomStatus: current.sbomStatus,
              relatedPackages: [
                {
                  advisory: current.advisory,
                  packages: current.packages,
                },
              ],
            };
            return [...prev, newItemInArray];
          }
        }, [] as SbomOfVulnerability[])
    );
  });

  const summary = sboms.reduce((prev, current) => {
    const sbomStatus = current.sbomStatus;
    return {
      ...prev,
      total: prev.total + 1,
      sbomStatus: {
        ...prev.sbomStatus,
        [sbomStatus]: prev.sbomStatus[sbomStatus] + 1,
      },
    };
  }, DEFAULT_SUMMARY);

  return {
    sboms,
    summary,
  };
};

export const useSbomsOfVulnerability = (sbomId: string) => {
  const {
    vulnerability,
    isFetching: isFetchingAdvisories,
    fetchError: fetchErrorAdvisories,
  } = useFetchVulnerabilityById(sbomId);

  const result = React.useMemo(() => {
    return advisoryToModels(vulnerability?.advisories || []);
  }, [vulnerability]);

  return {
    data: result,
    isFetching: isFetchingAdvisories,
    fetchError: fetchErrorAdvisories,
  };
};
