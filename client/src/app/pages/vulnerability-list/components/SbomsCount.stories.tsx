import React from "react";

import type { Meta, StoryObj } from "@storybook/react";
import { SbomsCount } from "./SbomsCount";
import { SbomOfVulnerabilitySummary } from "@app/hooks/domain-controls/useSbomsOfVulnerability";
import { AxiosError } from "axios";
import { http, HttpResponse } from "msw";
import { cveDetails } from "@mocks/handlers";
import getSboms from "@mocks/data/sbom/list.json";
import { fn } from "@storybook/test";
import * as actual from "@app/hooks/domain-controls/useSbomsOfVulnerability";

const useSbomsOfVulnerability = fn(actual.useSbomsOfVulnerability).mockName(
  "useSbomsOfVulnerability"
);

type StoryArgs = {
  fetchError?: AxiosError<unknown, any>;
  isFetching?: boolean;
  summary?: SbomOfVulnerabilitySummary;
  vulnerabilityId: string;
};

const meta: Meta<typeof SbomsCount> = {
  title: "Components/VulnerabilityList/SbomsCount",
  component: SbomsCount,
};

export default meta;

type Story = StoryObj<StoryArgs>;

export const DefaultState: Story = {
  args: {
    isFetching: true,
    vulnerabilityId: "CVE-2023-0481",
  },
  decorators: [
    (Story) => {
      // useSbomsOfVulnerability.mockReturnValueOnce({
      //   isFetching: true,
      //   fetchError: null,
      //   summary: {
      //     total: 0,
      //     status: {
      //       affected: 0,
      //       fixed: 0,
      //       not_affected: 0,
      //       known_not_affected: 0,
      //     },
      //   },
      //   sboms: [],
      // });

      // mockUseFetchVulnerabilityById.mockReturnValueOnce({
      //   vulnerability: cve20230481 as VulnerabilityDetails,
      //   isFetching: true,
      //   fetchError: {
      //     message: "A message here",
      //     isAxiosError: false,
      //     toJSON: () => new Object(),
      //     name: "A name here",
      //   },
      // });

      // mockUseSbomsOfVulnerability.mockReturnValueOnce({
      //   isFetching: true,
      //   fetchError: {
      //     message: "A message here",
      //     isAxiosError: false,
      //     toJSON: () => new Object(),
      //     name: "A name here",
      //   },
      //   summary: {
      //     total: 0,
      //     status: {
      //       affected: 0,
      //       fixed: 0,
      //       not_affected: 0,
      //       known_not_affected: 0,
      //     },
      //   },
      //   sboms: [],
      // });
      return <Story />;
    },
  ],
  parameters: {
    msw: {
      handlers: [
        // override the handler for vulnerability ID to provide
        // custom state
        http.get("/api/v2/vulnerability/:id", ({ params }) => {
          const { id } = params;

          if (!id) {
            return new HttpResponse(null, { status: 404 });
          }

          const data = cveDetails[id as string];

          if (!data) {
            return new HttpResponse("CVE not found", { status: 404 });
          }

          return HttpResponse.json({
            ...data,
            advisories: [],
            fetchError: {
              message: "A message here",
              isAxiosError: false,
              toJSON: () => new Object(),
              name: "A name here",
            },
            error: false,
          });
        }),
      ],
    },
  },
  // async beforeEach() {
  //   useSbomsOfVulnerability.mockReturnValue({
  //     isFetching: true,
  //     fetchError: {
  //       message: "A message here",
  //       isAxiosError: false,
  //       toJSON: () => new Object(),
  //       name: "A name here",
  //     },
  //     summary: {
  //       total: 0,
  //       status: {
  //         affected: 0,
  //         fixed: 0,
  //         not_affected: 0,
  //         known_not_affected: 0,
  //       },
  //     },
  //     sboms: [],
  //   });
  // }
};

export const ErrorState: Story = {
  args: {
    vulnerabilityId: "CVE-2022-45787",
  },
  async beforeEach() {
    useSbomsOfVulnerability.mockReturnValue({
      isFetching: false,
      fetchError: {
        message: "A message here",
        isAxiosError: false,
        toJSON: () => new Object(),
        name: "A name here",
      },
      data: {
        summary: {
          total: 5,
          sbomStatus: {
            affected: 3,
            fixed: 2,
            not_affected: 0,
            known_not_affected: 0,
          },
        },
        sboms: [],
      },
    });
  },
  parameters: {
    isFetching: false,
    fetchError: {
      isAxiosError: true,
      message: "Oh, no. Something's gone wrong.",
      name: "Human coder error",
      toJSON: (data?: any) => new Object(data),
    },
    summary: {
      total: 5,
      status: { fixed: 0, not_affected: 0, known_not_affected: 0, affected: 0 },
    },
    mockReturnValue: {
      "CVE-2022-45787": {
        vulnerability: null,
        isFetching: false,
        fetchError: "Error fetching data",
      },
    },
  },
};

export const PopulatedState: Story = {
  args: {
    isFetching: false,
    vulnerabilityId: "CVE-2023-0044",
  },
  async beforeEach() {
    useSbomsOfVulnerability.mockReturnValue({
      isFetching: false,
      fetchError: {
        message: "A message here",
        isAxiosError: false,
        toJSON: () => new Object(),
        name: "A name here",
      },
      data: {
        summary: {
          total: 0,
          sbomStatus: {
            affected: 0,
            fixed: 0,
            not_affected: 0,
            known_not_affected: 0,
          },
        },
        sboms: [],
      },
    });
  },
  parameters: {
    mockReturnValue: getSboms,
  },
};
