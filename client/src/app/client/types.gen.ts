// This file is auto-generated by @hey-api/openapi-ts

export type AdvisoryDetails = AdvisoryHead & (null | SourceDocument) & {
    /**
     * Average (arithmetic mean) score of the advisory aggregated from *all* related vulnerability assertions.
     */
    average_score: number | null;
    average_severity: null | Severity;
    /**
     * Vulnerabilities addressed within this advisory.
     */
    vulnerabilities: Array<AdvisoryVulnerabilitySummary>;
};

export type AdvisoryHead = {
    /**
     * The identifier of the advisory, as provided by the document.
     */
    document_id: string;
    /**
     * The identifier of the advisory, as assigned by the issuing organization.
     */
    identifier: string;
    issuer: null | OrganizationSummary;
    /**
     * Informational labels attached by the system or users to this advisory.
     */
    labels: Labels;
    /**
     * The date (in RFC3339 format) of when the advisory was last modified, if any.
     */
    modified?: string | null;
    /**
     * The date (in RFC3339 format) of when the advisory was published, if any.
     */
    published: string | null;
    /**
     * The title of the advisory as assigned by the issuing organization.
     */
    title: string | null;
    /**
     * The opaque UUID of the advisory.
     */
    uuid: string;
    /**
     * The date (in RFC3339 format) of when the advisory was withdrawn, if any.
     */
    withdrawn: string | null;
};

export type AdvisorySummary = AdvisoryHead & (null | SourceDocument) & {
    /**
     * Average (arithmetic mean) score of the advisory aggregated from *all* related vulnerability assertions.
     */
    average_score: number | null;
    /**
     * Average (arithmetic mean) severity of the advisory aggregated from *all* related vulnerability assertions.
     */
    average_severity: string | null;
    /**
     * Vulnerabilities addressed within this advisory.
     */
    vulnerabilities: Array<AdvisoryVulnerabilityHead>;
};

export type AdvisoryVulnerabilityHead = VulnerabilityHead & {
    /**
     * The average (arithmetic mean) score this advisory assigns to
     * the particular vulnerability.
     */
    score?: number | null;
    severity?: null | Severity;
};

/**
 * Summary of information from this advisory regarding a single specific vulnerability.
 */
export type AdvisoryVulnerabilitySummary = AdvisoryVulnerabilityHead & {
    /**
     * All CVSS3 scores from the advisory for the given vulnerability.
     * May include several, varying by minor version of the CVSS3 vector.
     */
    cvss3_scores: Array<string>;
};

export type AnalysisRequest = {
    purls: Array<string>;
};

export type AnalysisResponse = {
    [key: string]: Array<VulnerabilityDetails>;
};

export type AnalysisStatus = {
    /**
     * The number of graphs loaded in memory
     */
    graph_count: number;
    /**
     * The number of SBOMs found in the database
     */
    sbom_count: number;
};

export type BasePurlDetails = BasePurlHead & {
    versions: Array<VersionedPurlSummary>;
};

export type BasePurlHead = {
    /**
     * The actual base PURL
     */
    purl: Purl;
    /**
     * The ID of the base PURL
     */
    uuid: string;
};

export type BasePurlSummary = BasePurlHead;

export type BaseSummary = {
    cpe: Array<Cpe>;
    document_id: string;
    name: string;
    node_id: string;
    product_name: string;
    product_version: string;
    published: string;
    purl: Array<Purl>;
    sbom_id: string;
    version: string;
};

export type BinaryByteSize = string;

export type ClearlyDefinedCurationImporter = CommonImporter & {
    source?: string;
    types?: Array<ClearlyDefinedPackageType>;
};

export type ClearlyDefinedImporter = CommonImporter & {
    source?: string;
    types?: Array<ClearlyDefinedPackageType>;
};

export type ClearlyDefinedPackageType = 'composer' | 'crate' | 'deb' | 'gem' | 'git' | 'go' | 'maven' | 'npm' | 'nuget' | 'pod' | 'pypi';

export type CommonImporter = {
    /**
     * A description for users.
     */
    description?: string | null;
    /**
     * A flag to disable the importer, without deleting it.
     */
    disabled?: boolean;
    /**
     * Labels which will be applied to the ingested documents.
     */
    labels?: Labels;
    /**
     * The period the importer should be run.
     */
    period: string;
};

export type Cpe = string;

export type CsafImporter = CommonImporter & {
    fetchRetries?: number | null;
    ignoreMissing?: boolean;
    onlyPatterns?: Array<string>;
    source: string;
    v3Signatures?: boolean;
};

export type CveImporter = CommonImporter & {
    source?: string;
    startYear?: number | null;
    years?: Array<number>;
};

export type CweImporter = CommonImporter & {
    source?: string;
};

export type ExternalReferenceQuery = {
    cpe?: null | Cpe;
    purl?: null | Purl;
};

/**
 * Identifier to a document, prefixed with the ID type.
 *
 * Either an internal ID of the document with the `urn:uuid:` scheme. Or using a digest, with the digest prefix. For example, `sha256:`.
 */
export type Id = string;

export type Importer = ImporterData & {
    name: string;
};

export type ImporterConfiguration = {
    sbom: SbomImporter;
} | {
    csaf: CsafImporter;
} | {
    osv: OsvImporter;
} | {
    cve: CveImporter;
} | {
    clearlyDefined: ClearlyDefinedImporter;
} | {
    clearlyDefinedCuration: ClearlyDefinedCurationImporter;
} | {
    cwe: CweImporter;
};

export type ImporterData = {
    configuration: ImporterConfiguration;
    /**
     * The continuation token of the importer.
     */
    continuation?: unknown;
    /**
     * The last state change
     */
    lastChange: string;
    /**
     * The error of the last run (empty if successful)
     */
    lastError?: string | null;
    /**
     * The last run (successful or not)
     */
    lastRun?: string | null;
    /**
     * The last successful run
     */
    lastSuccess?: string | null;
    /**
     * The current progress.
     */
    progress?: Progress;
    /**
     * The current state of the importer
     */
    state: State;
};

export type ImporterReport = {
    /**
     * The time the report was created
     */
    creation: string;
    /**
     * Errors captured by the report
     */
    error?: string | null;
    /**
     * The ID of the report
     */
    id: string;
    /**
     * The name of the importer this report belongs to
     */
    importer: string;
    report?: null | Report;
};

/**
 * The result of the ingestion process
 */
export type IngestResult = {
    /**
     * The ID declared by the document
     */
    document_id?: string | null;
    /**
     * The internal ID of the document
     */
    id: Id;
    /**
     * Warnings that occurred during the import process
     */
    warnings?: Array<string>;
};

export type Labels = {
    [key: string]: string;
};

export type LicenseSummary = {
    id: string;
    license: string;
    purls: number;
    spdx_license_exceptions: Array<string>;
    spdx_licenses: Array<string>;
};

export type Message = {
    /**
     * The message
     */
    message: string;
    /**
     * The severity of the message
     */
    severity: Severity;
};

export type Node = BaseSummary & {
    /**
     * All ancestors of this node. [`None`] if not requested on this level.
     */
    ancestors?: Array<Node> | null;
    /**
     * All descendents of this node. [`None`] if not requested on this level.
     */
    descendants?: Array<Node> | null;
    relationship?: null | Relationship;
};

export type OrganizationDetails = OrganizationHead & {
    /**
     * Advisories issued by the organization, if any.
     */
    advisories: Array<AdvisoryHead>;
};

/**
 * An organization who may issue advisories, product SBOMs, or
 * otherwise be involved in supply-chain evidence.
 */
export type OrganizationHead = {
    /**
     * The `CPE` key of the organization, if known.
     */
    cpe_key: string | null;
    /**
     * The opaque UUID of the organization.
     */
    id: string;
    /**
     * The name of the organization.
     */
    name: string;
    /**
     * The website of the organization, if known.
     */
    website: string | null;
};

export type OrganizationSummary = OrganizationHead;

export type OsvImporter = CommonImporter & {
    /**
     * An optional branch. Will use the default branch otherwise.
     */
    branch?: string | null;
    /**
     * An optional path to start searching for documents. Will use the root of the repository otherwise.
     */
    path?: string | null;
    /**
     * The URL to the git repository of the OSV data
     */
    source: string;
    startYear?: number | null;
    years?: Array<number>;
};

export type PaginatedResultsAdvisorySummary = {
    items: Array<AdvisoryHead & (null | SourceDocument) & {
        /**
         * Average (arithmetic mean) score of the advisory aggregated from *all* related vulnerability assertions.
         */
        average_score: number | null;
        /**
         * Average (arithmetic mean) severity of the advisory aggregated from *all* related vulnerability assertions.
         */
        average_severity: string | null;
        /**
         * Vulnerabilities addressed within this advisory.
         */
        vulnerabilities: Array<AdvisoryVulnerabilityHead>;
    }>;
    total: number;
};

export type PaginatedResultsBasePurlSummary = {
    items: Array<BasePurlHead>;
    total: number;
};

export type PaginatedResultsImporterReport = {
    items: Array<{
        /**
         * The time the report was created
         */
        creation: string;
        /**
         * Errors captured by the report
         */
        error?: string | null;
        /**
         * The ID of the report
         */
        id: string;
        /**
         * The name of the importer this report belongs to
         */
        importer: string;
        report?: null | Report;
    }>;
    total: number;
};

export type PaginatedResultsLicenseSummary = {
    items: Array<{
        id: string;
        license: string;
        purls: number;
        spdx_license_exceptions: Array<string>;
        spdx_licenses: Array<string>;
    }>;
    total: number;
};

export type PaginatedResultsNode = {
    items: Array<BaseSummary & {
        /**
         * All ancestors of this node. [`None`] if not requested on this level.
         */
        ancestors?: Array<Node> | null;
        /**
         * All descendents of this node. [`None`] if not requested on this level.
         */
        descendants?: Array<Node> | null;
        relationship?: null | Relationship;
    }>;
    total: number;
};

export type PaginatedResultsProductSummary = {
    items: Array<ProductHead & {
        vendor: null | OrganizationSummary;
        versions: Array<ProductVersionHead>;
    }>;
    total: number;
};

export type PaginatedResultsPurlSummary = {
    items: Array<PurlHead & {
        base: BasePurlHead;
        /**
         * @deprecated
         */
        qualifiers: {
            [key: string]: string;
        };
        version: VersionedPurlHead;
    }>;
    total: number;
};

export type PaginatedResultsSbomPackage = {
    items: Array<{
        /**
         * CPEs identifying the package
         */
        cpe: Array<string>;
        /**
         * An optional group/namespace for an SBOM package
         */
        group?: string | null;
        /**
         * The SBOM internal ID of a package
         */
        id: string;
        /**
         * The name of the package in the SBOM
         */
        name: string;
        /**
         * PURLs identifying the package
         */
        purl: Array<PurlSummary>;
        /**
         * An optional version for an SBOM package
         */
        version?: string | null;
    }>;
    total: number;
};

export type PaginatedResultsSbomPackageRelation = {
    items: Array<{
        package: SbomPackage;
        relationship: Relationship;
    }>;
    total: number;
};

export type PaginatedResultsSbomSummary = {
    items: Array<SbomHead & (null | SourceDocument) & {
        described_by: Array<SbomPackage>;
    }>;
    total: number;
};

export type PaginatedResultsSpdxLicenseSummary = {
    items: Array<{
        id: string;
        name: string;
    }>;
    total: number;
};

export type PaginatedResultsVulnerabilitySummary = {
    items: Array<VulnerabilityHead & {
        advisories: Array<VulnerabilityAdvisoryHead>;
        /**
         * Average (arithmetic mean) score of the vulnerability aggregated from *all* related advisories.
         */
        average_score: number | null;
        average_severity: null | Severity;
    }>;
    total: number;
};

export type ProductDetails = ProductHead & {
    vendor: null | OrganizationSummary;
    versions: Array<ProductVersionDetails>;
};

export type ProductHead = {
    id: string;
    name: string;
};

export type ProductSbomHead = {
    labels: Labels;
    published: string | null;
};

export type ProductSummary = ProductHead & {
    vendor: null | OrganizationSummary;
    versions: Array<ProductVersionHead>;
};

export type ProductVersionDetails = ProductVersionHead & {
    sbom?: null | ProductSbomHead;
};

export type ProductVersionHead = {
    id: string;
    sbom_id?: string;
    version: string;
};

export type Progress = (null | ProgressDetails) & {
    message?: string | null;
};

export type ProgressDetails = {
    /**
     * The current processed items.
     */
    current: number;
    /**
     * The estimated time of completion.
     */
    estimatedCompletion: string;
    /**
     * The estimated remaining time in seconds.
     */
    estimatedSecondsRemaining: number;
    /**
     * Progress in percent (0..=1)
     */
    percent: number;
    /**
     * The average processing rate (per second).
     */
    rate: number;
    /**
     * The total number of items to be processed.
     */
    total: number;
};

export type Purl = string;

export type PurlAdvisory = AdvisoryHead & {
    status: Array<PurlStatus>;
};

export type PurlDetails = PurlHead & {
    advisories: Array<PurlAdvisory>;
    base: BasePurlHead;
    licenses: Array<PurlLicenseSummary>;
    version: VersionedPurlHead;
};

export type PurlHead = {
    /**
     * The actual qualified PURL
     */
    purl: Purl;
    /**
     * The ID of the qualified PURL
     */
    uuid: string;
};

export type PurlLicenseSummary = {
    licenses: Array<string>;
    sbom: SbomHead;
};

export type PurlStatus = {
    average_score: number;
    average_severity: Severity;
    context: null | StatusContext;
    status: string;
    vulnerability: VulnerabilityHead;
};

export type PurlSummary = PurlHead & {
    base: BasePurlHead;
    /**
     * @deprecated
     */
    qualifiers: {
        [key: string]: string;
    };
    version: VersionedPurlHead;
};

export type Relationship = 'contains' | 'dependency' | 'dev_dependency' | 'optional_dependency' | 'provided_dependency' | 'test_dependency' | 'runtime_dependency' | 'example' | 'generates' | 'ancestor_of' | 'variant' | 'build_tool' | 'dev_tool' | 'describes' | 'package' | 'undefined';

export type Report = {
    /**
     * End of the import run
     */
    endDate: string;
    /**
     * Messages emitted during processing
     */
    messages?: {
        [key: string]: {
            [key: string]: Array<Message>;
        };
    };
    /**
     * Number of processes items
     */
    numberOfItems?: number;
    /**
     * Start of the import run
     */
    startDate: string;
};

/**
 * A struct wrapping an item with a revision.
 *
 * If the revision should not be part of the payload, but e.g. an HTTP header (like `ETag`), this
 * struct can help carrying both pieces.
 */
export type RevisionedImporter = {
    /**
     * The revision.
     *
     * An opaque string that should have no meaning to the user, only to the backend.
     */
    revision: string;
    value: ImporterData & {
        name: string;
    };
};

export type SbomAdvisory = AdvisoryHead & {
    status: Array<SbomStatus>;
};

export type SbomHead = {
    /**
     * Authors of the SBOM
     */
    authors: Array<string>;
    data_licenses: Array<string>;
    document_id?: string | null;
    id: string;
    labels: Labels;
    name: string;
    /**
     * The number of packages this SBOM has
     */
    number_of_packages: number;
    published: string | null;
    /**
     * Suppliers of the SBOMs content
     */
    suppliers: Array<string>;
};

export type SbomImporter = CommonImporter & {
    fetchRetries?: number | null;
    ignoreMissing?: boolean;
    keys?: Array<string>;
    onlyPatterns?: Array<string>;
    sizeLimit?: null | BinaryByteSize;
    source: string;
    v3Signatures?: boolean;
};

export type SbomPackage = {
    /**
     * CPEs identifying the package
     */
    cpe: Array<string>;
    /**
     * An optional group/namespace for an SBOM package
     */
    group?: string | null;
    /**
     * The SBOM internal ID of a package
     */
    id: string;
    /**
     * The name of the package in the SBOM
     */
    name: string;
    /**
     * PURLs identifying the package
     */
    purl: Array<PurlSummary>;
    /**
     * An optional version for an SBOM package
     */
    version?: string | null;
};

export type SbomPackageRelation = {
    package: SbomPackage;
    relationship: Relationship;
};

export type SbomStatus = VulnerabilityHead & {
    average_score: number;
    average_severity: Severity;
    context?: null | StatusContext;
    packages: Array<SbomPackage>;
    status: string;
};

export type SbomSummary = SbomHead & (null | SourceDocument) & {
    described_by: Array<SbomPackage>;
};

/**
 * Qualitative Severity Rating Scale
 *
 * Described in CVSS v3.1 Specification: Section 5:
 * <https://www.first.org/cvss/specification-document#t17>
 *
 * > For some purposes it is useful to have a textual representation of the
 * > numeric Base, Temporal and Environmental scores.
 */
export type Severity = 'none' | 'low' | 'medium' | 'high' | 'critical';

export type SourceDocument = {
    /**
     * The timestamp the document was ingested
     */
    ingested: string;
    sha256: string;
    sha384: string;
    sha512: string;
    size: number;
};

export type SpdxLicenseDetails = SpdxLicenseSummary & {
    text: string;
};

export type SpdxLicenseSummary = {
    id: string;
    name: string;
};

export type State = 'waiting' | 'running';

export type StatusContext = {
    purl: Purl;
} | {
    cpe: string;
};

/**
 * An update set for labels.
 *
 * This is a key/value set, where the value can be a string for setting that value, or `null` for removing the label.
 *
 */
export type Update = {
    [key: string]: null | string;
};

export type VersionedPurlHead = {
    /**
     * The actual, versioned PURL
     */
    purl: Purl;
    /**
     * The ID of the versioned PURL
     */
    uuid: string;
    /**
     * The version from the PURL
     */
    version: string;
};

export type VersionedPurlSummary = VersionedPurlHead & {
    base: BasePurlHead;
    purls: Array<PurlHead>;
};

export type VulnerabilityAdvisoryHead = AdvisoryHead & {
    score: number | null;
    severity: null | Severity;
};

export type VulnerabilityAdvisoryStatus = {
    base_purl: BasePurlHead;
    context: null | StatusContext;
    version: string;
};

export type VulnerabilityAdvisorySummary = VulnerabilityAdvisoryHead & {
    /**
     * CVSS3 scores from this advisory regarding the vulnerability.
     */
    cvss3_scores: Array<string>;
    /**
     * The total number of vulnerabilities described by this advisory
     */
    number_of_vulnerabilities: number;
    purls: {
        [key: string]: Array<VulnerabilityAdvisoryStatus>;
    };
    /**
     * SBOMs claimed by this advisory to be addressed by this vulnerability.
     */
    sboms: Array<VulnerabilitySbomStatus>;
};

export type VulnerabilityDetails = VulnerabilityHead & {
    /**
     * Advisories addressing this vulnerability, if any.
     */
    advisories: Array<VulnerabilityAdvisorySummary>;
    /**
     * Average (arithmetic mean) score of the vulnerability aggregated from *all* related advisories.
     */
    average_score: number | null;
    average_severity: null | Severity;
};

export type VulnerabilityHead = {
    /**
     * Associated CWE, if any.
     */
    cwes: Array<string>;
    /**
     * The description of the vulnerability, if known.
     */
    description: string | null;
    /**
     * The date (in RFC3339 format) of when the vulnerability was discovered, if any.
     */
    discovered: string | null;
    /**
     * The globally-unique identifier for the vulnerability.
     * Traditionally (but not required) refers to the assigned
     * CVE identifier.
     */
    identifier: string;
    /**
     * The date (in RFC3339 format) of when the vulnerability was last modified, if any.
     */
    modified: string | null;
    normative: boolean;
    /**
     * The date (in RFC3339 format) of when the vulnerability was published, if any.
     */
    published: string | null;
    /**
     * The date (in RFC3339 format) of when software containing the vulnerability first released, if known.
     */
    released: string | null;
    /**
     * The date (in RFC3339 format) of when the vulnerability identifier was reserved, if any.
     */
    reserved: string | null;
    /**
     * The title of the vulnerability, if known.
     */
    title: string | null;
    /**
     * The date (in RFC3339 format) of when the vulnerability was last withdrawn, if any.
     */
    withdrawn: string | null;
};

export type VulnerabilitySbomStatus = SbomHead & {
    purl_statuses: {
        [key: string]: Array<PurlSummary>;
    };
    version?: string | null;
};

export type VulnerabilitySummary = VulnerabilityHead & {
    advisories: Array<VulnerabilityAdvisoryHead>;
    /**
     * Average (arithmetic mean) score of the vulnerability aggregated from *all* related advisories.
     */
    average_score: number | null;
    average_severity: null | Severity;
};

export type InfoData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/.well-known/trustify';
};

export type InfoResponses = {
    /**
     * Get information
     */
    200: {
        build?: {
            [key: string]: unknown;
        };
        version: string;
    };
};

export type InfoResponse = InfoResponses[keyof InfoResponses];

export type ListAdvisoriesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * EBNF grammar for the _q_ parameter:
         * ```text
         * q = ( values | filter ) { '&' q }
         * values = value { '|', values }
         * filter = field, operator, values
         * operator = "=" | "!=" | "~" | "!~" | ">=" | ">" | "<=" | "<"
         * value = (* any text but escape special characters with '\' *)
         * field = (* must match an entity attribute name *)
         * ```
         * Any values in a _q_ will result in a case-insensitive "full
         * text search", effectively producing an OR clause of LIKE
         * clauses for every string-ish field in the resource being
         * queried.
         *
         * Examples:
         * - `foo` - any field containing 'foo'
         * - `foo|bar` - any field containing either 'foo' OR 'bar'
         * - `foo&bar` - some field contains 'foo' AND some field contains 'bar'
         *
         * A _filter_ can further constrain the results. The filter's
         * field name must correspond to one of the resource's
         * attributes. If it doesn't, an error will be returned
         * containing a list of the valid fields for that resource.
         *
         * The value 'null' is treated specially for [not]equal filters:
         * it returns resources on which the field isn't set. Use the
         * LIKE operator, `~`, to match a literal "null" string.
         *
         * Examples:
         * - `name=foo` - entity's _name_ matches 'foo' exactly
         * - `name~foo` - entity's _name_ contains 'foo', case-insensitive
         * - `name~foo|bar` - entity's _name_ contains either 'foo' OR 'bar', case-insensitive
         * - `name=null` - entity's _name_ isn't set
         * - `published>3 days ago` - date values can be "human time"
         *
         * Multiple full text searches and/or filters should be
         * '&'-delimited -- they are logically AND'd together.
         *
         * - `red hat|fedora&labels:type=cve|osv&published>last wednesday 17:00`
         *
         * Fields corresponding to JSON objects in the database may use a
         * ':' to delimit the column name and the object key,
         * e.g. `purl:qualifiers:type=pom`
         *
         * Any operator or special character, e.g. '|', '&', within a
         * value should be escaped by prefixing it with a backslash.
         *
         */
        q?: string;
        /**
         * EBNF grammar for the _sort_ parameter:
         * ```text
         * sort = field [ ':', order ] { ',' sort }
         * order = ( "asc" | "desc" )
         * field = (* must match the name of entity's attributes *)
         * ```
         * The optional _order_ should be one of "asc" or "desc". If
         * omitted, the order defaults to "asc".
         *
         * Each _field_ name must correspond to one of the columns of the
         * table holding the entities being queried. Those corresponding
         * to JSON objects in the database may use a ':' to delimit the
         * column name and the object key,
         * e.g. `purl:qualifiers:type:desc`
         *
         */
        sort?: string;
        /**
         * The first item to return, skipping all that come before it.
         *
         * NOTE: The order of items is defined by the API being called.
         */
        offset?: number;
        /**
         * The maximum number of entries to return.
         *
         * Zero means: no limit
         */
        limit?: number;
        deprecated?: 'Ignore' | 'Consider';
    };
    url: '/api/v2/advisory';
};

export type ListAdvisoriesResponses = {
    /**
     * Matching vulnerabilities
     */
    200: PaginatedResultsAdvisorySummary;
};

export type ListAdvisoriesResponse = ListAdvisoriesResponses[keyof ListAdvisoriesResponses];

export type UploadAdvisoryData = {
    body: Blob | File;
    path?: never;
    query: {
        /**
         * Optional issuer if it cannot be determined from advisory contents.
         */
        issuer?: string | null;
        /**
         * Optional labels.
         *
         * Only use keys with a prefix of `labels.`
         */
        labels: Labels;
        /**
         * The format of the uploaded document.
         */
        format?: 'oSV' | 'cSAF' | 'cVE' | 'sPDX' | 'cycloneDX' | 'clearlyDefinedCuration' | 'clearlyDefined' | 'cweCatalog' | 'advisory' | 'sBOM' | 'unknown';
    };
    url: '/api/v2/advisory';
};

export type UploadAdvisoryErrors = {
    /**
     * The file could not be parsed as an advisory
     */
    400: unknown;
};

export type UploadAdvisoryResponses = {
    /**
     * Upload a file
     */
    201: unknown;
};

export type PatchAdvisoryLabelsData = {
    body: Update;
    path: {
        /**
         * Digest/hash of the document, prefixed by hash type, such as 'sha256:<hash>' or 'urn:uuid:<uuid>'
         */
        id: Id;
    };
    query?: never;
    url: '/api/v2/advisory/{id}/label';
};

export type PatchAdvisoryLabelsErrors = {
    /**
     * The advisory could not be found
     */
    404: unknown;
};

export type PatchAdvisoryLabelsResponses = {
    /**
     * Modified the labels of the advisory
     */
    204: void;
};

export type PatchAdvisoryLabelsResponse = PatchAdvisoryLabelsResponses[keyof PatchAdvisoryLabelsResponses];

export type UpdateAdvisoryLabelsData = {
    body: Labels;
    path: {
        /**
         * Digest/hash of the document, prefixed by hash type, such as 'sha256:<hash>' or 'urn:uuid:<uuid>'
         */
        id: Id;
    };
    query?: never;
    url: '/api/v2/advisory/{id}/label';
};

export type UpdateAdvisoryLabelsErrors = {
    /**
     * The advisory could not be found
     */
    404: unknown;
};

export type UpdateAdvisoryLabelsResponses = {
    /**
     * Replaced the labels of the advisory
     */
    204: void;
};

export type UpdateAdvisoryLabelsResponse = UpdateAdvisoryLabelsResponses[keyof UpdateAdvisoryLabelsResponses];

export type DeleteAdvisoryData = {
    body?: never;
    path: {
        key: Id;
    };
    query?: never;
    url: '/api/v2/advisory/{key}';
};

export type DeleteAdvisoryErrors = {
    /**
     * Matching advisory not found
     */
    404: unknown;
};

export type DeleteAdvisoryResponses = {
    /**
     * Matching advisory
     */
    200: AdvisoryDetails;
};

export type DeleteAdvisoryResponse = DeleteAdvisoryResponses[keyof DeleteAdvisoryResponses];

export type GetAdvisoryData = {
    body?: never;
    path: {
        key: Id;
    };
    query?: never;
    url: '/api/v2/advisory/{key}';
};

export type GetAdvisoryErrors = {
    /**
     * Matching advisory not found
     */
    404: unknown;
};

export type GetAdvisoryResponses = {
    /**
     * Matching advisory
     */
    200: AdvisoryDetails;
};

export type GetAdvisoryResponse = GetAdvisoryResponses[keyof GetAdvisoryResponses];

export type DownloadAdvisoryData = {
    body?: never;
    path: {
        key: Id;
    };
    query?: never;
    url: '/api/v2/advisory/{key}/download';
};

export type DownloadAdvisoryErrors = {
    /**
     * The document could not be found
     */
    404: unknown;
};

export type DownloadAdvisoryResponses = {
    /**
     * Download a an advisory
     */
    200: Blob | File;
};

export type DownloadAdvisoryResponse = DownloadAdvisoryResponses[keyof DownloadAdvisoryResponses];

export type SearchComponentData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * EBNF grammar for the _q_ parameter:
         * ```text
         * q = ( values | filter ) { '&' q }
         * values = value { '|', values }
         * filter = field, operator, values
         * operator = "=" | "!=" | "~" | "!~" | ">=" | ">" | "<=" | "<"
         * value = (* any text but escape special characters with '\' *)
         * field = (* must match an entity attribute name *)
         * ```
         * Any values in a _q_ will result in a case-insensitive "full
         * text search", effectively producing an OR clause of LIKE
         * clauses for every string-ish field in the resource being
         * queried.
         *
         * Examples:
         * - `foo` - any field containing 'foo'
         * - `foo|bar` - any field containing either 'foo' OR 'bar'
         * - `foo&bar` - some field contains 'foo' AND some field contains 'bar'
         *
         * A _filter_ can further constrain the results. The filter's
         * field name must correspond to one of the resource's
         * attributes. If it doesn't, an error will be returned
         * containing a list of the valid fields for that resource.
         *
         * The value 'null' is treated specially for [not]equal filters:
         * it returns resources on which the field isn't set. Use the
         * LIKE operator, `~`, to match a literal "null" string.
         *
         * Examples:
         * - `name=foo` - entity's _name_ matches 'foo' exactly
         * - `name~foo` - entity's _name_ contains 'foo', case-insensitive
         * - `name~foo|bar` - entity's _name_ contains either 'foo' OR 'bar', case-insensitive
         * - `name=null` - entity's _name_ isn't set
         * - `published>3 days ago` - date values can be "human time"
         *
         * Multiple full text searches and/or filters should be
         * '&'-delimited -- they are logically AND'd together.
         *
         * - `red hat|fedora&labels:type=cve|osv&published>last wednesday 17:00`
         *
         * Fields corresponding to JSON objects in the database may use a
         * ':' to delimit the column name and the object key,
         * e.g. `purl:qualifiers:type=pom`
         *
         * Any operator or special character, e.g. '|', '&', within a
         * value should be escaped by prefixing it with a backslash.
         *
         */
        q?: string;
        /**
         * EBNF grammar for the _sort_ parameter:
         * ```text
         * sort = field [ ':', order ] { ',' sort }
         * order = ( "asc" | "desc" )
         * field = (* must match the name of entity's attributes *)
         * ```
         * The optional _order_ should be one of "asc" or "desc". If
         * omitted, the order defaults to "asc".
         *
         * Each _field_ name must correspond to one of the columns of the
         * table holding the entities being queried. Those corresponding
         * to JSON objects in the database may use a ':' to delimit the
         * column name and the object key,
         * e.g. `purl:qualifiers:type:desc`
         *
         */
        sort?: string;
        /**
         * The first item to return, skipping all that come before it.
         *
         * NOTE: The order of items is defined by the API being called.
         */
        offset?: number;
        /**
         * The maximum number of entries to return.
         *
         * Zero means: no limit
         */
        limit?: number;
        /**
         * The level of ancestors to return.
         *
         * Zero, the default, meaning none.
         */
        ancestors?: number;
        /**
         * The level of descendants to return.
         *
         * Zero, the default, meaning none.
         */
        descendants?: number;
        /**
         * A set of relationships to filter for, deserialized from a
         * comma-delimited string
         *
         * An empty set, the default, meaning all relationships.
         */
        relationships?: string;
    };
    url: '/api/v2/analysis/component';
};

export type SearchComponentErrors = {
    /**
     * The user did not provide valid authentication credentials
     */
    401: unknown;
    /**
     * The user lacks the required permission
     */
    403: unknown;
};

export type SearchComponentResponses = {
    /**
     * Retrieved component(s) located by search
     */
    200: PaginatedResultsNode;
};

export type SearchComponentResponse = SearchComponentResponses[keyof SearchComponentResponses];

export type GetComponentData = {
    body?: never;
    path: {
        /**
         * provide component name, URL-encoded pURL, or CPE itself
         */
        key: string;
        /**
         * EBNF grammar for the _q_ parameter:
         * ```text
         * q = ( values | filter ) { '&' q }
         * values = value { '|', values }
         * filter = field, operator, values
         * operator = "=" | "!=" | "~" | "!~" | ">=" | ">" | "<=" | "<"
         * value = (* any text but escape special characters with '\' *)
         * field = (* must match an entity attribute name *)
         * ```
         * Any values in a _q_ will result in a case-insensitive "full
         * text search", effectively producing an OR clause of LIKE
         * clauses for every string-ish field in the resource being
         * queried.
         *
         * Examples:
         * - `foo` - any field containing 'foo'
         * - `foo|bar` - any field containing either 'foo' OR 'bar'
         * - `foo&bar` - some field contains 'foo' AND some field contains 'bar'
         *
         * A _filter_ can further constrain the results. The filter's
         * field name must correspond to one of the resource's
         * attributes. If it doesn't, an error will be returned
         * containing a list of the valid fields for that resource.
         *
         * The value 'null' is treated specially for [not]equal filters:
         * it returns resources on which the field isn't set. Use the
         * LIKE operator, `~`, to match a literal "null" string.
         *
         * Examples:
         * - `name=foo` - entity's _name_ matches 'foo' exactly
         * - `name~foo` - entity's _name_ contains 'foo', case-insensitive
         * - `name~foo|bar` - entity's _name_ contains either 'foo' OR 'bar', case-insensitive
         * - `name=null` - entity's _name_ isn't set
         * - `published>3 days ago` - date values can be "human time"
         *
         * Multiple full text searches and/or filters should be
         * '&'-delimited -- they are logically AND'd together.
         *
         * - `red hat|fedora&labels:type=cve|osv&published>last wednesday 17:00`
         *
         * Fields corresponding to JSON objects in the database may use a
         * ':' to delimit the column name and the object key,
         * e.g. `purl:qualifiers:type=pom`
         *
         * Any operator or special character, e.g. '|', '&', within a
         * value should be escaped by prefixing it with a backslash.
         *
         */
        q: string;
        /**
         * EBNF grammar for the _sort_ parameter:
         * ```text
         * sort = field [ ':', order ] { ',' sort }
         * order = ( "asc" | "desc" )
         * field = (* must match the name of entity's attributes *)
         * ```
         * The optional _order_ should be one of "asc" or "desc". If
         * omitted, the order defaults to "asc".
         *
         * Each _field_ name must correspond to one of the columns of the
         * table holding the entities being queried. Those corresponding
         * to JSON objects in the database may use a ':' to delimit the
         * column name and the object key,
         * e.g. `purl:qualifiers:type:desc`
         *
         */
        sort: string;
    };
    query?: {
        /**
         * The first item to return, skipping all that come before it.
         *
         * NOTE: The order of items is defined by the API being called.
         */
        offset?: number;
        /**
         * The maximum number of entries to return.
         *
         * Zero means: no limit
         */
        limit?: number;
        /**
         * The level of ancestors to return.
         *
         * Zero, the default, meaning none.
         */
        ancestors?: number;
        /**
         * The level of descendants to return.
         *
         * Zero, the default, meaning none.
         */
        descendants?: number;
        /**
         * A set of relationships to filter for, deserialized from a
         * comma-delimited string
         *
         * An empty set, the default, meaning all relationships.
         */
        relationships?: string;
    };
    url: '/api/v2/analysis/component/{key}';
};

export type GetComponentErrors = {
    /**
     * The user did not provide valid authentication credentials
     */
    401: unknown;
    /**
     * The user lacks the required permission
     */
    403: unknown;
};

export type GetComponentResponses = {
    /**
     * Retrieved component(s) located by name, pURL, or CPE
     */
    200: PaginatedResultsNode;
};

export type GetComponentResponse = GetComponentResponses[keyof GetComponentResponses];

export type SearchLatestComponentData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * EBNF grammar for the _q_ parameter:
         * ```text
         * q = ( values | filter ) { '&' q }
         * values = value { '|', values }
         * filter = field, operator, values
         * operator = "=" | "!=" | "~" | "!~" | ">=" | ">" | "<=" | "<"
         * value = (* any text but escape special characters with '\' *)
         * field = (* must match an entity attribute name *)
         * ```
         * Any values in a _q_ will result in a case-insensitive "full
         * text search", effectively producing an OR clause of LIKE
         * clauses for every string-ish field in the resource being
         * queried.
         *
         * Examples:
         * - `foo` - any field containing 'foo'
         * - `foo|bar` - any field containing either 'foo' OR 'bar'
         * - `foo&bar` - some field contains 'foo' AND some field contains 'bar'
         *
         * A _filter_ can further constrain the results. The filter's
         * field name must correspond to one of the resource's
         * attributes. If it doesn't, an error will be returned
         * containing a list of the valid fields for that resource.
         *
         * The value 'null' is treated specially for [not]equal filters:
         * it returns resources on which the field isn't set. Use the
         * LIKE operator, `~`, to match a literal "null" string.
         *
         * Examples:
         * - `name=foo` - entity's _name_ matches 'foo' exactly
         * - `name~foo` - entity's _name_ contains 'foo', case-insensitive
         * - `name~foo|bar` - entity's _name_ contains either 'foo' OR 'bar', case-insensitive
         * - `name=null` - entity's _name_ isn't set
         * - `published>3 days ago` - date values can be "human time"
         *
         * Multiple full text searches and/or filters should be
         * '&'-delimited -- they are logically AND'd together.
         *
         * - `red hat|fedora&labels:type=cve|osv&published>last wednesday 17:00`
         *
         * Fields corresponding to JSON objects in the database may use a
         * ':' to delimit the column name and the object key,
         * e.g. `purl:qualifiers:type=pom`
         *
         * Any operator or special character, e.g. '|', '&', within a
         * value should be escaped by prefixing it with a backslash.
         *
         */
        q?: string;
        /**
         * EBNF grammar for the _sort_ parameter:
         * ```text
         * sort = field [ ':', order ] { ',' sort }
         * order = ( "asc" | "desc" )
         * field = (* must match the name of entity's attributes *)
         * ```
         * The optional _order_ should be one of "asc" or "desc". If
         * omitted, the order defaults to "asc".
         *
         * Each _field_ name must correspond to one of the columns of the
         * table holding the entities being queried. Those corresponding
         * to JSON objects in the database may use a ':' to delimit the
         * column name and the object key,
         * e.g. `purl:qualifiers:type:desc`
         *
         */
        sort?: string;
        /**
         * The first item to return, skipping all that come before it.
         *
         * NOTE: The order of items is defined by the API being called.
         */
        offset?: number;
        /**
         * The maximum number of entries to return.
         *
         * Zero means: no limit
         */
        limit?: number;
        /**
         * The level of ancestors to return.
         *
         * Zero, the default, meaning none.
         */
        ancestors?: number;
        /**
         * The level of descendants to return.
         *
         * Zero, the default, meaning none.
         */
        descendants?: number;
        /**
         * A set of relationships to filter for, deserialized from a
         * comma-delimited string
         *
         * An empty set, the default, meaning all relationships.
         */
        relationships?: string;
    };
    url: '/api/v2/analysis/latest/component';
};

export type SearchLatestComponentErrors = {
    /**
     * The user did not provide valid authentication credentials
     */
    401: unknown;
    /**
     * The user lacks the required permission
     */
    403: unknown;
};

export type SearchLatestComponentResponses = {
    /**
     * Retrieved latest component(s) located by search
     */
    200: PaginatedResultsNode;
};

export type SearchLatestComponentResponse = SearchLatestComponentResponses[keyof SearchLatestComponentResponses];

export type GetLatestComponentData = {
    body?: never;
    path: {
        /**
         * provide component name, URL-encoded pURL, or CPE itself
         */
        key: string;
        /**
         * EBNF grammar for the _q_ parameter:
         * ```text
         * q = ( values | filter ) { '&' q }
         * values = value { '|', values }
         * filter = field, operator, values
         * operator = "=" | "!=" | "~" | "!~" | ">=" | ">" | "<=" | "<"
         * value = (* any text but escape special characters with '\' *)
         * field = (* must match an entity attribute name *)
         * ```
         * Any values in a _q_ will result in a case-insensitive "full
         * text search", effectively producing an OR clause of LIKE
         * clauses for every string-ish field in the resource being
         * queried.
         *
         * Examples:
         * - `foo` - any field containing 'foo'
         * - `foo|bar` - any field containing either 'foo' OR 'bar'
         * - `foo&bar` - some field contains 'foo' AND some field contains 'bar'
         *
         * A _filter_ can further constrain the results. The filter's
         * field name must correspond to one of the resource's
         * attributes. If it doesn't, an error will be returned
         * containing a list of the valid fields for that resource.
         *
         * The value 'null' is treated specially for [not]equal filters:
         * it returns resources on which the field isn't set. Use the
         * LIKE operator, `~`, to match a literal "null" string.
         *
         * Examples:
         * - `name=foo` - entity's _name_ matches 'foo' exactly
         * - `name~foo` - entity's _name_ contains 'foo', case-insensitive
         * - `name~foo|bar` - entity's _name_ contains either 'foo' OR 'bar', case-insensitive
         * - `name=null` - entity's _name_ isn't set
         * - `published>3 days ago` - date values can be "human time"
         *
         * Multiple full text searches and/or filters should be
         * '&'-delimited -- they are logically AND'd together.
         *
         * - `red hat|fedora&labels:type=cve|osv&published>last wednesday 17:00`
         *
         * Fields corresponding to JSON objects in the database may use a
         * ':' to delimit the column name and the object key,
         * e.g. `purl:qualifiers:type=pom`
         *
         * Any operator or special character, e.g. '|', '&', within a
         * value should be escaped by prefixing it with a backslash.
         *
         */
        q: string;
        /**
         * EBNF grammar for the _sort_ parameter:
         * ```text
         * sort = field [ ':', order ] { ',' sort }
         * order = ( "asc" | "desc" )
         * field = (* must match the name of entity's attributes *)
         * ```
         * The optional _order_ should be one of "asc" or "desc". If
         * omitted, the order defaults to "asc".
         *
         * Each _field_ name must correspond to one of the columns of the
         * table holding the entities being queried. Those corresponding
         * to JSON objects in the database may use a ':' to delimit the
         * column name and the object key,
         * e.g. `purl:qualifiers:type:desc`
         *
         */
        sort: string;
    };
    query?: {
        /**
         * The first item to return, skipping all that come before it.
         *
         * NOTE: The order of items is defined by the API being called.
         */
        offset?: number;
        /**
         * The maximum number of entries to return.
         *
         * Zero means: no limit
         */
        limit?: number;
        /**
         * The level of ancestors to return.
         *
         * Zero, the default, meaning none.
         */
        ancestors?: number;
        /**
         * The level of descendants to return.
         *
         * Zero, the default, meaning none.
         */
        descendants?: number;
        /**
         * A set of relationships to filter for, deserialized from a
         * comma-delimited string
         *
         * An empty set, the default, meaning all relationships.
         */
        relationships?: string;
    };
    url: '/api/v2/analysis/latest/component/{key}';
};

export type GetLatestComponentErrors = {
    /**
     * The user did not provide valid authentication credentials
     */
    401: unknown;
    /**
     * The user lacks the required permission
     */
    403: unknown;
};

export type GetLatestComponentResponses = {
    /**
     * Retrieved latest component(s) located by name, pURL, or CPE
     */
    200: PaginatedResultsNode;
};

export type GetLatestComponentResponse = GetLatestComponentResponses[keyof GetLatestComponentResponses];

export type RenderSbomGraphData = {
    body?: never;
    path: {
        /**
         * ID of the SBOM
         */
        sbom: string;
        /**
         * Renderer to use
         */
        ext: 'gv';
    };
    query?: never;
    url: '/api/v2/analysis/sbom/{sbom}/render.{ext}';
};

export type RenderSbomGraphErrors = {
    /**
     * The user did not provide valid authentication credentials
     */
    401: unknown;
    /**
     * The user lacks the required permission
     */
    403: unknown;
    /**
     * The SBOM was not found
     */
    404: unknown;
    /**
     * Unsupported rendering format
     */
    415: unknown;
};

export type RenderSbomGraphResponses = {
    /**
     * A rendered version of the SBOM graph in the format requested
     */
    200: string;
};

export type RenderSbomGraphResponse = RenderSbomGraphResponses[keyof RenderSbomGraphResponses];

export type StatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v2/analysis/status';
};

export type StatusErrors = {
    /**
     * The user did not provide valid authentication credentials
     */
    401: unknown;
    /**
     * The user lacks the required permission
     */
    403: unknown;
};

export type StatusResponses = {
    /**
     * Analysis status
     */
    200: AnalysisStatus;
};

export type StatusResponse = StatusResponses[keyof StatusResponses];

export type UploadDatasetData = {
    body: Blob | File;
    path?: never;
    query: {
        /**
         * Optional labels.
         *
         * Only use keys with a prefix of `labels.`
         */
        labels: Labels;
    };
    url: '/api/v2/dataset';
};

export type UploadDatasetErrors = {
    /**
     * The file could not be parsed as an dataset
     */
    400: unknown;
};

export type UploadDatasetResponses = {
    /**
     * Uploaded the dataset
     */
    201: unknown;
};

export type ListImportersData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/v2/importer';
};

export type ListImportersResponses = {
    /**
     * List importer configurations
     */
    200: Array<Importer>;
};

export type ListImportersResponse = ListImportersResponses[keyof ListImportersResponses];

export type DeleteImporterData = {
    body?: never;
    headers?: {
        /**
         * The revision to delete
         */
        'if-match'?: string | null;
    };
    path: {
        /**
         * The name of the importer
         */
        name: string;
    };
    query?: never;
    url: '/api/v2/importer/{name}';
};

export type DeleteImporterResponses = {
    /**
     * Delete the importer configuration
     */
    201: unknown;
};

export type GetImporterData = {
    body?: never;
    path: {
        /**
         * The name of the importer
         */
        name: string;
    };
    query?: never;
    url: '/api/v2/importer/{name}';
};

export type GetImporterErrors = {
    /**
     * An importer with that name could not be found
     */
    404: unknown;
};

export type GetImporterResponses = {
    /**
     * Retrieved importer configuration
     */
    200: RevisionedImporter;
};

export type GetImporterResponse = GetImporterResponses[keyof GetImporterResponses];

export type PatchImporterData = {
    body: unknown;
    headers?: {
        /**
         * The revision to update
         */
        'if-match'?: string | null;
    };
    path: {
        /**
         * The name of the importer
         */
        name: string;
    };
    query?: never;
    url: '/api/v2/importer/{name}';
};

export type PatchImporterErrors = {
    /**
     * An importer with that name does not exist
     */
    409: unknown;
    /**
     * The provided if-match header did not match the stored revision
     */
    412: unknown;
};

export type PatchImporterResponses = {
    /**
     * Created a new importer configuration
     */
    201: unknown;
};

export type CreateImporterData = {
    body: ImporterConfiguration;
    path: {
        /**
         * The name of the importer
         */
        name: string;
    };
    query?: never;
    url: '/api/v2/importer/{name}';
};

export type CreateImporterErrors = {
    /**
     * An importer with that name already exists
     */
    409: unknown;
};

export type CreateImporterResponses = {
    /**
     * Created a new importer configuration
     */
    201: unknown;
};

export type UpdateImporterData = {
    body: ImporterConfiguration;
    headers?: {
        /**
         * The revision to update
         */
        'if-match'?: string | null;
    };
    path: {
        /**
         * The name of the importer
         */
        name: string;
    };
    query?: never;
    url: '/api/v2/importer/{name}';
};

export type UpdateImporterErrors = {
    /**
     * An importer with that name does not exist
     */
    409: unknown;
    /**
     * The provided if-match header did not match the stored revision
     */
    412: unknown;
};

export type UpdateImporterResponses = {
    /**
     * Updated the importer configuration
     */
    201: unknown;
};

export type EnableImporterData = {
    body: boolean;
    headers?: {
        /**
         * The revision to update
         */
        'if-match'?: string | null;
    };
    path: {
        /**
         * The name of the importer
         */
        name: string;
    };
    query?: never;
    url: '/api/v2/importer/{name}/enabled';
};

export type EnableImporterErrors = {
    /**
     * An importer with that name does not exist
     */
    404: unknown;
    /**
     * The provided if-match header did not match the stored revision
     */
    412: unknown;
};

export type EnableImporterResponses = {
    /**
     * Updated the enable state
     */
    201: unknown;
};

export type ForceRunImporterData = {
    body: boolean;
    headers?: {
        /**
         * The revision to update
         */
        'if-match'?: string | null;
    };
    path: {
        /**
         * The name of the importer
         */
        name: string;
    };
    query?: never;
    url: '/api/v2/importer/{name}/force';
};

export type ForceRunImporterErrors = {
    /**
     * An importer with that name does not exist
     */
    404: unknown;
    /**
     * The provided if-match header did not match the stored revision
     */
    412: unknown;
};

export type ForceRunImporterResponses = {
    /**
     * Updated the state
     */
    201: unknown;
};

export type ListImporterReportsData = {
    body?: never;
    path: {
        name: string;
    };
    query?: never;
    url: '/api/v2/importer/{name}/report';
};

export type ListImporterReportsResponses = {
    /**
     * Retrieved importer reports
     */
    200: PaginatedResultsImporterReport;
};

export type ListImporterReportsResponse = ListImporterReportsResponses[keyof ListImporterReportsResponses];

export type ListSpdxLicensesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * EBNF grammar for the _q_ parameter:
         * ```text
         * q = ( values | filter ) { '&' q }
         * values = value { '|', values }
         * filter = field, operator, values
         * operator = "=" | "!=" | "~" | "!~" | ">=" | ">" | "<=" | "<"
         * value = (* any text but escape special characters with '\' *)
         * field = (* must match an entity attribute name *)
         * ```
         * Any values in a _q_ will result in a case-insensitive "full
         * text search", effectively producing an OR clause of LIKE
         * clauses for every string-ish field in the resource being
         * queried.
         *
         * Examples:
         * - `foo` - any field containing 'foo'
         * - `foo|bar` - any field containing either 'foo' OR 'bar'
         * - `foo&bar` - some field contains 'foo' AND some field contains 'bar'
         *
         * A _filter_ can further constrain the results. The filter's
         * field name must correspond to one of the resource's
         * attributes. If it doesn't, an error will be returned
         * containing a list of the valid fields for that resource.
         *
         * The value 'null' is treated specially for [not]equal filters:
         * it returns resources on which the field isn't set. Use the
         * LIKE operator, `~`, to match a literal "null" string.
         *
         * Examples:
         * - `name=foo` - entity's _name_ matches 'foo' exactly
         * - `name~foo` - entity's _name_ contains 'foo', case-insensitive
         * - `name~foo|bar` - entity's _name_ contains either 'foo' OR 'bar', case-insensitive
         * - `name=null` - entity's _name_ isn't set
         * - `published>3 days ago` - date values can be "human time"
         *
         * Multiple full text searches and/or filters should be
         * '&'-delimited -- they are logically AND'd together.
         *
         * - `red hat|fedora&labels:type=cve|osv&published>last wednesday 17:00`
         *
         * Fields corresponding to JSON objects in the database may use a
         * ':' to delimit the column name and the object key,
         * e.g. `purl:qualifiers:type=pom`
         *
         * Any operator or special character, e.g. '|', '&', within a
         * value should be escaped by prefixing it with a backslash.
         *
         */
        q?: string;
        /**
         * EBNF grammar for the _sort_ parameter:
         * ```text
         * sort = field [ ':', order ] { ',' sort }
         * order = ( "asc" | "desc" )
         * field = (* must match the name of entity's attributes *)
         * ```
         * The optional _order_ should be one of "asc" or "desc". If
         * omitted, the order defaults to "asc".
         *
         * Each _field_ name must correspond to one of the columns of the
         * table holding the entities being queried. Those corresponding
         * to JSON objects in the database may use a ':' to delimit the
         * column name and the object key,
         * e.g. `purl:qualifiers:type:desc`
         *
         */
        sort?: string;
        /**
         * The first item to return, skipping all that come before it.
         *
         * NOTE: The order of items is defined by the API being called.
         */
        offset?: number;
        /**
         * The maximum number of entries to return.
         *
         * Zero means: no limit
         */
        limit?: number;
    };
    url: '/api/v2/license/spdx/license';
};

export type ListSpdxLicensesResponses = {
    /**
     * Matching licenses
     */
    200: PaginatedResultsSpdxLicenseSummary;
};

export type ListSpdxLicensesResponse = ListSpdxLicensesResponses[keyof ListSpdxLicensesResponses];

export type GetSpdxLicenseData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/v2/license/spdx/license/{id}';
};

export type GetSpdxLicenseResponses = {
    /**
     * SPDX license details
     */
    200: SpdxLicenseDetails;
};

export type GetSpdxLicenseResponse = GetSpdxLicenseResponses[keyof GetSpdxLicenseResponses];

export type ListOrganizationsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * EBNF grammar for the _q_ parameter:
         * ```text
         * q = ( values | filter ) { '&' q }
         * values = value { '|', values }
         * filter = field, operator, values
         * operator = "=" | "!=" | "~" | "!~" | ">=" | ">" | "<=" | "<"
         * value = (* any text but escape special characters with '\' *)
         * field = (* must match an entity attribute name *)
         * ```
         * Any values in a _q_ will result in a case-insensitive "full
         * text search", effectively producing an OR clause of LIKE
         * clauses for every string-ish field in the resource being
         * queried.
         *
         * Examples:
         * - `foo` - any field containing 'foo'
         * - `foo|bar` - any field containing either 'foo' OR 'bar'
         * - `foo&bar` - some field contains 'foo' AND some field contains 'bar'
         *
         * A _filter_ can further constrain the results. The filter's
         * field name must correspond to one of the resource's
         * attributes. If it doesn't, an error will be returned
         * containing a list of the valid fields for that resource.
         *
         * The value 'null' is treated specially for [not]equal filters:
         * it returns resources on which the field isn't set. Use the
         * LIKE operator, `~`, to match a literal "null" string.
         *
         * Examples:
         * - `name=foo` - entity's _name_ matches 'foo' exactly
         * - `name~foo` - entity's _name_ contains 'foo', case-insensitive
         * - `name~foo|bar` - entity's _name_ contains either 'foo' OR 'bar', case-insensitive
         * - `name=null` - entity's _name_ isn't set
         * - `published>3 days ago` - date values can be "human time"
         *
         * Multiple full text searches and/or filters should be
         * '&'-delimited -- they are logically AND'd together.
         *
         * - `red hat|fedora&labels:type=cve|osv&published>last wednesday 17:00`
         *
         * Fields corresponding to JSON objects in the database may use a
         * ':' to delimit the column name and the object key,
         * e.g. `purl:qualifiers:type=pom`
         *
         * Any operator or special character, e.g. '|', '&', within a
         * value should be escaped by prefixing it with a backslash.
         *
         */
        q?: string;
        /**
         * EBNF grammar for the _sort_ parameter:
         * ```text
         * sort = field [ ':', order ] { ',' sort }
         * order = ( "asc" | "desc" )
         * field = (* must match the name of entity's attributes *)
         * ```
         * The optional _order_ should be one of "asc" or "desc". If
         * omitted, the order defaults to "asc".
         *
         * Each _field_ name must correspond to one of the columns of the
         * table holding the entities being queried. Those corresponding
         * to JSON objects in the database may use a ':' to delimit the
         * column name and the object key,
         * e.g. `purl:qualifiers:type:desc`
         *
         */
        sort?: string;
        /**
         * The first item to return, skipping all that come before it.
         *
         * NOTE: The order of items is defined by the API being called.
         */
        offset?: number;
        /**
         * The maximum number of entries to return.
         *
         * Zero means: no limit
         */
        limit?: number;
    };
    url: '/api/v2/organization';
};

export type ListOrganizationsResponses = {
    /**
     * Matching organizations
     */
    200: OrganizationSummary;
};

export type ListOrganizationsResponse = ListOrganizationsResponses[keyof ListOrganizationsResponses];

export type GetOrganizationData = {
    body?: never;
    path: {
        /**
         * Opaque ID of the organization
         */
        id: string;
    };
    query?: never;
    url: '/api/v2/organization/{id}';
};

export type GetOrganizationErrors = {
    /**
     * Matching organization not found
     */
    404: unknown;
};

export type GetOrganizationResponses = {
    /**
     * Matching organization
     */
    200: OrganizationDetails;
};

export type GetOrganizationResponse = GetOrganizationResponses[keyof GetOrganizationResponses];

export type ListProductsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * EBNF grammar for the _q_ parameter:
         * ```text
         * q = ( values | filter ) { '&' q }
         * values = value { '|', values }
         * filter = field, operator, values
         * operator = "=" | "!=" | "~" | "!~" | ">=" | ">" | "<=" | "<"
         * value = (* any text but escape special characters with '\' *)
         * field = (* must match an entity attribute name *)
         * ```
         * Any values in a _q_ will result in a case-insensitive "full
         * text search", effectively producing an OR clause of LIKE
         * clauses for every string-ish field in the resource being
         * queried.
         *
         * Examples:
         * - `foo` - any field containing 'foo'
         * - `foo|bar` - any field containing either 'foo' OR 'bar'
         * - `foo&bar` - some field contains 'foo' AND some field contains 'bar'
         *
         * A _filter_ can further constrain the results. The filter's
         * field name must correspond to one of the resource's
         * attributes. If it doesn't, an error will be returned
         * containing a list of the valid fields for that resource.
         *
         * The value 'null' is treated specially for [not]equal filters:
         * it returns resources on which the field isn't set. Use the
         * LIKE operator, `~`, to match a literal "null" string.
         *
         * Examples:
         * - `name=foo` - entity's _name_ matches 'foo' exactly
         * - `name~foo` - entity's _name_ contains 'foo', case-insensitive
         * - `name~foo|bar` - entity's _name_ contains either 'foo' OR 'bar', case-insensitive
         * - `name=null` - entity's _name_ isn't set
         * - `published>3 days ago` - date values can be "human time"
         *
         * Multiple full text searches and/or filters should be
         * '&'-delimited -- they are logically AND'd together.
         *
         * - `red hat|fedora&labels:type=cve|osv&published>last wednesday 17:00`
         *
         * Fields corresponding to JSON objects in the database may use a
         * ':' to delimit the column name and the object key,
         * e.g. `purl:qualifiers:type=pom`
         *
         * Any operator or special character, e.g. '|', '&', within a
         * value should be escaped by prefixing it with a backslash.
         *
         */
        q?: string;
        /**
         * EBNF grammar for the _sort_ parameter:
         * ```text
         * sort = field [ ':', order ] { ',' sort }
         * order = ( "asc" | "desc" )
         * field = (* must match the name of entity's attributes *)
         * ```
         * The optional _order_ should be one of "asc" or "desc". If
         * omitted, the order defaults to "asc".
         *
         * Each _field_ name must correspond to one of the columns of the
         * table holding the entities being queried. Those corresponding
         * to JSON objects in the database may use a ':' to delimit the
         * column name and the object key,
         * e.g. `purl:qualifiers:type:desc`
         *
         */
        sort?: string;
        /**
         * The first item to return, skipping all that come before it.
         *
         * NOTE: The order of items is defined by the API being called.
         */
        offset?: number;
        /**
         * The maximum number of entries to return.
         *
         * Zero means: no limit
         */
        limit?: number;
    };
    url: '/api/v2/product';
};

export type ListProductsResponses = {
    /**
     * Matching products
     */
    200: PaginatedResultsProductSummary;
};

export type ListProductsResponse = ListProductsResponses[keyof ListProductsResponses];

export type DeleteProductData = {
    body?: never;
    path: {
        /**
         * Opaque ID of the product
         */
        id: string;
    };
    query?: never;
    url: '/api/v2/product/{id}';
};

export type DeleteProductErrors = {
    /**
     * Matching product not found
     */
    404: unknown;
};

export type DeleteProductResponses = {
    /**
     * Matching product
     */
    200: ProductDetails;
};

export type DeleteProductResponse = DeleteProductResponses[keyof DeleteProductResponses];

export type GetProductData = {
    body?: never;
    path: {
        /**
         * Opaque ID of the product
         */
        id: string;
    };
    query?: never;
    url: '/api/v2/product/{id}';
};

export type GetProductErrors = {
    /**
     * Matching product not found
     */
    404: unknown;
};

export type GetProductResponses = {
    /**
     * Matching product
     */
    200: ProductDetails;
};

export type GetProductResponse = GetProductResponses[keyof GetProductResponses];

export type ListPurlData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * EBNF grammar for the _q_ parameter:
         * ```text
         * q = ( values | filter ) { '&' q }
         * values = value { '|', values }
         * filter = field, operator, values
         * operator = "=" | "!=" | "~" | "!~" | ">=" | ">" | "<=" | "<"
         * value = (* any text but escape special characters with '\' *)
         * field = (* must match an entity attribute name *)
         * ```
         * Any values in a _q_ will result in a case-insensitive "full
         * text search", effectively producing an OR clause of LIKE
         * clauses for every string-ish field in the resource being
         * queried.
         *
         * Examples:
         * - `foo` - any field containing 'foo'
         * - `foo|bar` - any field containing either 'foo' OR 'bar'
         * - `foo&bar` - some field contains 'foo' AND some field contains 'bar'
         *
         * A _filter_ can further constrain the results. The filter's
         * field name must correspond to one of the resource's
         * attributes. If it doesn't, an error will be returned
         * containing a list of the valid fields for that resource.
         *
         * The value 'null' is treated specially for [not]equal filters:
         * it returns resources on which the field isn't set. Use the
         * LIKE operator, `~`, to match a literal "null" string.
         *
         * Examples:
         * - `name=foo` - entity's _name_ matches 'foo' exactly
         * - `name~foo` - entity's _name_ contains 'foo', case-insensitive
         * - `name~foo|bar` - entity's _name_ contains either 'foo' OR 'bar', case-insensitive
         * - `name=null` - entity's _name_ isn't set
         * - `published>3 days ago` - date values can be "human time"
         *
         * Multiple full text searches and/or filters should be
         * '&'-delimited -- they are logically AND'd together.
         *
         * - `red hat|fedora&labels:type=cve|osv&published>last wednesday 17:00`
         *
         * Fields corresponding to JSON objects in the database may use a
         * ':' to delimit the column name and the object key,
         * e.g. `purl:qualifiers:type=pom`
         *
         * Any operator or special character, e.g. '|', '&', within a
         * value should be escaped by prefixing it with a backslash.
         *
         */
        q?: string;
        /**
         * EBNF grammar for the _sort_ parameter:
         * ```text
         * sort = field [ ':', order ] { ',' sort }
         * order = ( "asc" | "desc" )
         * field = (* must match the name of entity's attributes *)
         * ```
         * The optional _order_ should be one of "asc" or "desc". If
         * omitted, the order defaults to "asc".
         *
         * Each _field_ name must correspond to one of the columns of the
         * table holding the entities being queried. Those corresponding
         * to JSON objects in the database may use a ':' to delimit the
         * column name and the object key,
         * e.g. `purl:qualifiers:type:desc`
         *
         */
        sort?: string;
        /**
         * The first item to return, skipping all that come before it.
         *
         * NOTE: The order of items is defined by the API being called.
         */
        offset?: number;
        /**
         * The maximum number of entries to return.
         *
         * Zero means: no limit
         */
        limit?: number;
    };
    url: '/api/v2/purl';
};

export type ListPurlResponses = {
    /**
     * All relevant matching qualified PURLs
     */
    200: PaginatedResultsPurlSummary;
};

export type ListPurlResponse = ListPurlResponses[keyof ListPurlResponses];

export type ListBasePurlsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * EBNF grammar for the _q_ parameter:
         * ```text
         * q = ( values | filter ) { '&' q }
         * values = value { '|', values }
         * filter = field, operator, values
         * operator = "=" | "!=" | "~" | "!~" | ">=" | ">" | "<=" | "<"
         * value = (* any text but escape special characters with '\' *)
         * field = (* must match an entity attribute name *)
         * ```
         * Any values in a _q_ will result in a case-insensitive "full
         * text search", effectively producing an OR clause of LIKE
         * clauses for every string-ish field in the resource being
         * queried.
         *
         * Examples:
         * - `foo` - any field containing 'foo'
         * - `foo|bar` - any field containing either 'foo' OR 'bar'
         * - `foo&bar` - some field contains 'foo' AND some field contains 'bar'
         *
         * A _filter_ can further constrain the results. The filter's
         * field name must correspond to one of the resource's
         * attributes. If it doesn't, an error will be returned
         * containing a list of the valid fields for that resource.
         *
         * The value 'null' is treated specially for [not]equal filters:
         * it returns resources on which the field isn't set. Use the
         * LIKE operator, `~`, to match a literal "null" string.
         *
         * Examples:
         * - `name=foo` - entity's _name_ matches 'foo' exactly
         * - `name~foo` - entity's _name_ contains 'foo', case-insensitive
         * - `name~foo|bar` - entity's _name_ contains either 'foo' OR 'bar', case-insensitive
         * - `name=null` - entity's _name_ isn't set
         * - `published>3 days ago` - date values can be "human time"
         *
         * Multiple full text searches and/or filters should be
         * '&'-delimited -- they are logically AND'd together.
         *
         * - `red hat|fedora&labels:type=cve|osv&published>last wednesday 17:00`
         *
         * Fields corresponding to JSON objects in the database may use a
         * ':' to delimit the column name and the object key,
         * e.g. `purl:qualifiers:type=pom`
         *
         * Any operator or special character, e.g. '|', '&', within a
         * value should be escaped by prefixing it with a backslash.
         *
         */
        q?: string;
        /**
         * EBNF grammar for the _sort_ parameter:
         * ```text
         * sort = field [ ':', order ] { ',' sort }
         * order = ( "asc" | "desc" )
         * field = (* must match the name of entity's attributes *)
         * ```
         * The optional _order_ should be one of "asc" or "desc". If
         * omitted, the order defaults to "asc".
         *
         * Each _field_ name must correspond to one of the columns of the
         * table holding the entities being queried. Those corresponding
         * to JSON objects in the database may use a ':' to delimit the
         * column name and the object key,
         * e.g. `purl:qualifiers:type:desc`
         *
         */
        sort?: string;
        /**
         * The first item to return, skipping all that come before it.
         *
         * NOTE: The order of items is defined by the API being called.
         */
        offset?: number;
        /**
         * The maximum number of entries to return.
         *
         * Zero means: no limit
         */
        limit?: number;
    };
    url: '/api/v2/purl/base';
};

export type ListBasePurlsResponses = {
    /**
     * All relevant matching versionless base PURL
     */
    200: PaginatedResultsBasePurlSummary;
};

export type ListBasePurlsResponse = ListBasePurlsResponses[keyof ListBasePurlsResponses];

export type GetBasePurlData = {
    body?: never;
    path: {
        /**
         * opaque identifier for a base PURL, or a URL-encoded pURL itself
         */
        key: string;
    };
    query?: never;
    url: '/api/v2/purl/base/{key}';
};

export type GetBasePurlResponses = {
    /**
     * Details for the versionless base PURL
     */
    200: BasePurlDetails;
};

export type GetBasePurlResponse = GetBasePurlResponses[keyof GetBasePurlResponses];

export type GetPurlData = {
    body?: never;
    path: {
        /**
         * opaque identifier for a fully-qualified PURL, or URL-encoded pURL itself
         */
        key: string;
    };
    query?: {
        deprecated?: 'Ignore' | 'Consider';
    };
    url: '/api/v2/purl/{key}';
};

export type GetPurlResponses = {
    /**
     * Details for the qualified PURL
     */
    200: PurlDetails;
};

export type GetPurlResponse = GetPurlResponses[keyof GetPurlResponses];

export type ListSbomsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * EBNF grammar for the _q_ parameter:
         * ```text
         * q = ( values | filter ) { '&' q }
         * values = value { '|', values }
         * filter = field, operator, values
         * operator = "=" | "!=" | "~" | "!~" | ">=" | ">" | "<=" | "<"
         * value = (* any text but escape special characters with '\' *)
         * field = (* must match an entity attribute name *)
         * ```
         * Any values in a _q_ will result in a case-insensitive "full
         * text search", effectively producing an OR clause of LIKE
         * clauses for every string-ish field in the resource being
         * queried.
         *
         * Examples:
         * - `foo` - any field containing 'foo'
         * - `foo|bar` - any field containing either 'foo' OR 'bar'
         * - `foo&bar` - some field contains 'foo' AND some field contains 'bar'
         *
         * A _filter_ can further constrain the results. The filter's
         * field name must correspond to one of the resource's
         * attributes. If it doesn't, an error will be returned
         * containing a list of the valid fields for that resource.
         *
         * The value 'null' is treated specially for [not]equal filters:
         * it returns resources on which the field isn't set. Use the
         * LIKE operator, `~`, to match a literal "null" string.
         *
         * Examples:
         * - `name=foo` - entity's _name_ matches 'foo' exactly
         * - `name~foo` - entity's _name_ contains 'foo', case-insensitive
         * - `name~foo|bar` - entity's _name_ contains either 'foo' OR 'bar', case-insensitive
         * - `name=null` - entity's _name_ isn't set
         * - `published>3 days ago` - date values can be "human time"
         *
         * Multiple full text searches and/or filters should be
         * '&'-delimited -- they are logically AND'd together.
         *
         * - `red hat|fedora&labels:type=cve|osv&published>last wednesday 17:00`
         *
         * Fields corresponding to JSON objects in the database may use a
         * ':' to delimit the column name and the object key,
         * e.g. `purl:qualifiers:type=pom`
         *
         * Any operator or special character, e.g. '|', '&', within a
         * value should be escaped by prefixing it with a backslash.
         *
         */
        q?: string;
        /**
         * EBNF grammar for the _sort_ parameter:
         * ```text
         * sort = field [ ':', order ] { ',' sort }
         * order = ( "asc" | "desc" )
         * field = (* must match the name of entity's attributes *)
         * ```
         * The optional _order_ should be one of "asc" or "desc". If
         * omitted, the order defaults to "asc".
         *
         * Each _field_ name must correspond to one of the columns of the
         * table holding the entities being queried. Those corresponding
         * to JSON objects in the database may use a ':' to delimit the
         * column name and the object key,
         * e.g. `purl:qualifiers:type:desc`
         *
         */
        sort?: string;
        /**
         * The first item to return, skipping all that come before it.
         *
         * NOTE: The order of items is defined by the API being called.
         */
        offset?: number;
        /**
         * The maximum number of entries to return.
         *
         * Zero means: no limit
         */
        limit?: number;
    };
    url: '/api/v2/sbom';
};

export type ListSbomsResponses = {
    /**
     * Matching SBOMs
     */
    200: PaginatedResultsSbomSummary;
};

export type ListSbomsResponse = ListSbomsResponses[keyof ListSbomsResponses];

export type UploadSbomData = {
    body: Array<number>;
    path?: never;
    query: {
        /**
         * Optional labels.
         *
         * Only use keys with a prefix of `labels.`
         */
        labels: Labels;
        /**
         * The format of the uploaded document.
         */
        format?: 'oSV' | 'cSAF' | 'cVE' | 'sPDX' | 'cycloneDX' | 'clearlyDefinedCuration' | 'clearlyDefined' | 'cweCatalog' | 'advisory' | 'sBOM' | 'unknown';
        /**
         * Await loading the document into the analysis graph cache
         */
        cache?: 'skip' | 'queue' | 'wait';
    };
    url: '/api/v2/sbom';
};

export type UploadSbomErrors = {
    /**
     * The file could not be parsed as an SBOM
     */
    400: unknown;
};

export type UploadSbomResponses = {
    /**
     * Upload an SBOM
     */
    201: IngestResult;
};

export type UploadSbomResponse = UploadSbomResponses[keyof UploadSbomResponses];

export type ListRelatedSbomsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * EBNF grammar for the _q_ parameter:
         * ```text
         * q = ( values | filter ) { '&' q }
         * values = value { '|', values }
         * filter = field, operator, values
         * operator = "=" | "!=" | "~" | "!~" | ">=" | ">" | "<=" | "<"
         * value = (* any text but escape special characters with '\' *)
         * field = (* must match an entity attribute name *)
         * ```
         * Any values in a _q_ will result in a case-insensitive "full
         * text search", effectively producing an OR clause of LIKE
         * clauses for every string-ish field in the resource being
         * queried.
         *
         * Examples:
         * - `foo` - any field containing 'foo'
         * - `foo|bar` - any field containing either 'foo' OR 'bar'
         * - `foo&bar` - some field contains 'foo' AND some field contains 'bar'
         *
         * A _filter_ can further constrain the results. The filter's
         * field name must correspond to one of the resource's
         * attributes. If it doesn't, an error will be returned
         * containing a list of the valid fields for that resource.
         *
         * The value 'null' is treated specially for [not]equal filters:
         * it returns resources on which the field isn't set. Use the
         * LIKE operator, `~`, to match a literal "null" string.
         *
         * Examples:
         * - `name=foo` - entity's _name_ matches 'foo' exactly
         * - `name~foo` - entity's _name_ contains 'foo', case-insensitive
         * - `name~foo|bar` - entity's _name_ contains either 'foo' OR 'bar', case-insensitive
         * - `name=null` - entity's _name_ isn't set
         * - `published>3 days ago` - date values can be "human time"
         *
         * Multiple full text searches and/or filters should be
         * '&'-delimited -- they are logically AND'd together.
         *
         * - `red hat|fedora&labels:type=cve|osv&published>last wednesday 17:00`
         *
         * Fields corresponding to JSON objects in the database may use a
         * ':' to delimit the column name and the object key,
         * e.g. `purl:qualifiers:type=pom`
         *
         * Any operator or special character, e.g. '|', '&', within a
         * value should be escaped by prefixing it with a backslash.
         *
         */
        q?: string;
        /**
         * EBNF grammar for the _sort_ parameter:
         * ```text
         * sort = field [ ':', order ] { ',' sort }
         * order = ( "asc" | "desc" )
         * field = (* must match the name of entity's attributes *)
         * ```
         * The optional _order_ should be one of "asc" or "desc". If
         * omitted, the order defaults to "asc".
         *
         * Each _field_ name must correspond to one of the columns of the
         * table holding the entities being queried. Those corresponding
         * to JSON objects in the database may use a ':' to delimit the
         * column name and the object key,
         * e.g. `purl:qualifiers:type:desc`
         *
         */
        sort?: string;
        /**
         * The first item to return, skipping all that come before it.
         *
         * NOTE: The order of items is defined by the API being called.
         */
        offset?: number;
        /**
         * The maximum number of entries to return.
         *
         * Zero means: no limit
         */
        limit?: number;
        /**
         * Find by PURL
         */
        purl?: null | Purl;
        /**
         * Find by CPE
         */
        cpe?: null | Cpe;
    };
    url: '/api/v2/sbom/by-package';
};

export type ListRelatedSbomsResponses = {
    /**
     * Matching SBOMs
     */
    200: PaginatedResultsSbomSummary;
};

export type ListRelatedSbomsResponse = ListRelatedSbomsResponses[keyof ListRelatedSbomsResponses];

export type CountRelatedSbomsData = {
    body: Array<ExternalReferenceQuery>;
    path: {
        /**
         * Find by PURL
         */
        purl: null | Purl;
        /**
         * Find by CPE
         */
        cpe: null | Cpe;
    };
    query?: never;
    url: '/api/v2/sbom/count-by-package';
};

export type CountRelatedSbomsResponses = {
    /**
     * Number of matching SBOMs per package
     */
    200: Array<number>;
};

export type CountRelatedSbomsResponse = CountRelatedSbomsResponses[keyof CountRelatedSbomsResponses];

export type DeleteSbomData = {
    body?: never;
    path: {
        id: Id;
    };
    query?: never;
    url: '/api/v2/sbom/{id}';
};

export type DeleteSbomErrors = {
    /**
     * Matching SBOM not found
     */
    404: unknown;
};

export type DeleteSbomResponses = {
    /**
     * Matching SBOM
     */
    200: SbomSummary;
};

export type DeleteSbomResponse = DeleteSbomResponses[keyof DeleteSbomResponses];

export type GetSbomData = {
    body?: never;
    path: {
        id: Id;
    };
    query?: never;
    url: '/api/v2/sbom/{id}';
};

export type GetSbomErrors = {
    /**
     * Matching SBOM not found
     */
    404: unknown;
};

export type GetSbomResponses = {
    /**
     * Matching SBOM
     */
    200: SbomSummary;
};

export type GetSbomResponse = GetSbomResponses[keyof GetSbomResponses];

export type GetSbomAdvisoriesData = {
    body?: never;
    path: {
        id: Id;
    };
    query?: never;
    url: '/api/v2/sbom/{id}/advisory';
};

export type GetSbomAdvisoriesErrors = {
    /**
     * Matching SBOM not found
     */
    404: unknown;
};

export type GetSbomAdvisoriesResponses = {
    /**
     * Matching SBOM
     */
    200: Array<SbomAdvisory>;
};

export type GetSbomAdvisoriesResponse = GetSbomAdvisoriesResponses[keyof GetSbomAdvisoriesResponses];

export type PatchSbomLabelsData = {
    body: Update;
    path: {
        /**
         * Digest/hash of the document, prefixed by hash type, such as 'sha256:<hash>' or 'urn:uuid:<uuid>'
         */
        id: Id;
    };
    query?: never;
    url: '/api/v2/sbom/{id}/label';
};

export type PatchSbomLabelsErrors = {
    /**
     * The SBOM could not be found
     */
    404: unknown;
};

export type PatchSbomLabelsResponses = {
    /**
     * Modified the labels of the SBOM
     */
    204: void;
};

export type PatchSbomLabelsResponse = PatchSbomLabelsResponses[keyof PatchSbomLabelsResponses];

export type UpdateSbomLabelsData = {
    body: Labels;
    path: {
        /**
         * Digest/hash of the document, prefixed by hash type, such as 'sha256:<hash>' or 'urn:uuid:<uuid>'
         */
        id: Id;
    };
    query?: never;
    url: '/api/v2/sbom/{id}/label';
};

export type UpdateSbomLabelsErrors = {
    /**
     * The SBOM could not be found
     */
    404: unknown;
};

export type UpdateSbomLabelsResponses = {
    /**
     * Replaced the labels of the SBOM
     */
    204: void;
};

export type UpdateSbomLabelsResponse = UpdateSbomLabelsResponses[keyof UpdateSbomLabelsResponses];

export type GetLicenseExportData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/v2/sbom/{id}/license-export';
};

export type GetLicenseExportErrors = {
    /**
     * The document could not be found
     */
    404: unknown;
};

export type GetLicenseExportResponses = {
    /**
     * license gzip files
     */
    200: Array<number>;
};

export type GetLicenseExportResponse = GetLicenseExportResponses[keyof GetLicenseExportResponses];

export type ListPackagesData = {
    body?: never;
    path: {
        /**
         * ID of the SBOM to get packages for
         */
        id: string;
    };
    query?: {
        /**
         * EBNF grammar for the _q_ parameter:
         * ```text
         * q = ( values | filter ) { '&' q }
         * values = value { '|', values }
         * filter = field, operator, values
         * operator = "=" | "!=" | "~" | "!~" | ">=" | ">" | "<=" | "<"
         * value = (* any text but escape special characters with '\' *)
         * field = (* must match an entity attribute name *)
         * ```
         * Any values in a _q_ will result in a case-insensitive "full
         * text search", effectively producing an OR clause of LIKE
         * clauses for every string-ish field in the resource being
         * queried.
         *
         * Examples:
         * - `foo` - any field containing 'foo'
         * - `foo|bar` - any field containing either 'foo' OR 'bar'
         * - `foo&bar` - some field contains 'foo' AND some field contains 'bar'
         *
         * A _filter_ can further constrain the results. The filter's
         * field name must correspond to one of the resource's
         * attributes. If it doesn't, an error will be returned
         * containing a list of the valid fields for that resource.
         *
         * The value 'null' is treated specially for [not]equal filters:
         * it returns resources on which the field isn't set. Use the
         * LIKE operator, `~`, to match a literal "null" string.
         *
         * Examples:
         * - `name=foo` - entity's _name_ matches 'foo' exactly
         * - `name~foo` - entity's _name_ contains 'foo', case-insensitive
         * - `name~foo|bar` - entity's _name_ contains either 'foo' OR 'bar', case-insensitive
         * - `name=null` - entity's _name_ isn't set
         * - `published>3 days ago` - date values can be "human time"
         *
         * Multiple full text searches and/or filters should be
         * '&'-delimited -- they are logically AND'd together.
         *
         * - `red hat|fedora&labels:type=cve|osv&published>last wednesday 17:00`
         *
         * Fields corresponding to JSON objects in the database may use a
         * ':' to delimit the column name and the object key,
         * e.g. `purl:qualifiers:type=pom`
         *
         * Any operator or special character, e.g. '|', '&', within a
         * value should be escaped by prefixing it with a backslash.
         *
         */
        q?: string;
        /**
         * EBNF grammar for the _sort_ parameter:
         * ```text
         * sort = field [ ':', order ] { ',' sort }
         * order = ( "asc" | "desc" )
         * field = (* must match the name of entity's attributes *)
         * ```
         * The optional _order_ should be one of "asc" or "desc". If
         * omitted, the order defaults to "asc".
         *
         * Each _field_ name must correspond to one of the columns of the
         * table holding the entities being queried. Those corresponding
         * to JSON objects in the database may use a ':' to delimit the
         * column name and the object key,
         * e.g. `purl:qualifiers:type:desc`
         *
         */
        sort?: string;
        /**
         * The first item to return, skipping all that come before it.
         *
         * NOTE: The order of items is defined by the API being called.
         */
        offset?: number;
        /**
         * The maximum number of entries to return.
         *
         * Zero means: no limit
         */
        limit?: number;
    };
    url: '/api/v2/sbom/{id}/packages';
};

export type ListPackagesResponses = {
    /**
     * Packages
     */
    200: PaginatedResultsSbomPackage;
};

export type ListPackagesResponse = ListPackagesResponses[keyof ListPackagesResponses];

export type ListRelatedPackagesData = {
    body?: never;
    path: {
        /**
         * ID of SBOM to search packages in
         */
        id: string;
    };
    query?: {
        /**
         * The Package to use as reference
         */
        reference?: string | null;
        /**
         * Which side the reference should be on
         */
        which?: 'left' | 'right';
        /**
         * Optional relationship filter
         */
        relationship?: null | Relationship;
        /**
         * EBNF grammar for the _q_ parameter:
         * ```text
         * q = ( values | filter ) { '&' q }
         * values = value { '|', values }
         * filter = field, operator, values
         * operator = "=" | "!=" | "~" | "!~" | ">=" | ">" | "<=" | "<"
         * value = (* any text but escape special characters with '\' *)
         * field = (* must match an entity attribute name *)
         * ```
         * Any values in a _q_ will result in a case-insensitive "full
         * text search", effectively producing an OR clause of LIKE
         * clauses for every string-ish field in the resource being
         * queried.
         *
         * Examples:
         * - `foo` - any field containing 'foo'
         * - `foo|bar` - any field containing either 'foo' OR 'bar'
         * - `foo&bar` - some field contains 'foo' AND some field contains 'bar'
         *
         * A _filter_ can further constrain the results. The filter's
         * field name must correspond to one of the resource's
         * attributes. If it doesn't, an error will be returned
         * containing a list of the valid fields for that resource.
         *
         * The value 'null' is treated specially for [not]equal filters:
         * it returns resources on which the field isn't set. Use the
         * LIKE operator, `~`, to match a literal "null" string.
         *
         * Examples:
         * - `name=foo` - entity's _name_ matches 'foo' exactly
         * - `name~foo` - entity's _name_ contains 'foo', case-insensitive
         * - `name~foo|bar` - entity's _name_ contains either 'foo' OR 'bar', case-insensitive
         * - `name=null` - entity's _name_ isn't set
         * - `published>3 days ago` - date values can be "human time"
         *
         * Multiple full text searches and/or filters should be
         * '&'-delimited -- they are logically AND'd together.
         *
         * - `red hat|fedora&labels:type=cve|osv&published>last wednesday 17:00`
         *
         * Fields corresponding to JSON objects in the database may use a
         * ':' to delimit the column name and the object key,
         * e.g. `purl:qualifiers:type=pom`
         *
         * Any operator or special character, e.g. '|', '&', within a
         * value should be escaped by prefixing it with a backslash.
         *
         */
        q?: string;
        /**
         * EBNF grammar for the _sort_ parameter:
         * ```text
         * sort = field [ ':', order ] { ',' sort }
         * order = ( "asc" | "desc" )
         * field = (* must match the name of entity's attributes *)
         * ```
         * The optional _order_ should be one of "asc" or "desc". If
         * omitted, the order defaults to "asc".
         *
         * Each _field_ name must correspond to one of the columns of the
         * table holding the entities being queried. Those corresponding
         * to JSON objects in the database may use a ':' to delimit the
         * column name and the object key,
         * e.g. `purl:qualifiers:type:desc`
         *
         */
        sort?: string;
        /**
         * The first item to return, skipping all that come before it.
         *
         * NOTE: The order of items is defined by the API being called.
         */
        offset?: number;
        /**
         * The maximum number of entries to return.
         *
         * Zero means: no limit
         */
        limit?: number;
    };
    url: '/api/v2/sbom/{id}/related';
};

export type ListRelatedPackagesResponses = {
    /**
     * Packages
     */
    200: PaginatedResultsSbomPackageRelation;
};

export type ListRelatedPackagesResponse = ListRelatedPackagesResponses[keyof ListRelatedPackagesResponses];

export type DownloadSbomData = {
    body?: never;
    path: {
        key: Id;
    };
    query?: never;
    url: '/api/v2/sbom/{key}/download';
};

export type DownloadSbomErrors = {
    /**
     * The document could not be found
     */
    404: unknown;
};

export type DownloadSbomResponses = {
    /**
     * Download a an SBOM
     */
    200: Blob | File;
};

export type DownloadSbomResponse = DownloadSbomResponses[keyof DownloadSbomResponses];

export type DeleteUserPreferencesData = {
    body: unknown;
    headers?: {
        /**
         * The revision to delete
         */
        'if-match'?: string | null;
    };
    path: {
        /**
         * The key to the user preferences
         */
        key: string;
    };
    query?: never;
    url: '/api/v2/userPreference/{key}';
};

export type DeleteUserPreferencesErrors = {
    /**
     * The provided If-Match revision did not match the actual revision
     */
    412: unknown;
};

export type DeleteUserPreferencesResponses = {
    /**
     * User preferences are deleted
     */
    201: unknown;
};

export type GetUserPreferencesData = {
    body?: never;
    path: {
        /**
         * The key to the user preferences
         */
        key: string;
    };
    query?: never;
    url: '/api/v2/userPreference/{key}';
};

export type GetUserPreferencesErrors = {
    /**
     * Unknown user preference key
     */
    404: unknown;
};

export type GetUserPreferencesResponses = {
    /**
     * User preference stored under this key
     */
    200: unknown;
};

export type SetUserPreferencesData = {
    body: unknown;
    headers?: {
        /**
         * The revision to update
         */
        'if-match'?: string | null;
    };
    path: {
        /**
         * The key to the user preferences
         */
        key: string;
    };
    query?: never;
    url: '/api/v2/userPreference/{key}';
};

export type SetUserPreferencesErrors = {
    /**
     * The provided If-Match revision did not match the actual revision
     */
    412: unknown;
};

export type SetUserPreferencesResponses = {
    /**
     * User preference stored under this key
     */
    200: unknown;
};

export type ListVulnerabilitiesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * EBNF grammar for the _q_ parameter:
         * ```text
         * q = ( values | filter ) { '&' q }
         * values = value { '|', values }
         * filter = field, operator, values
         * operator = "=" | "!=" | "~" | "!~" | ">=" | ">" | "<=" | "<"
         * value = (* any text but escape special characters with '\' *)
         * field = (* must match an entity attribute name *)
         * ```
         * Any values in a _q_ will result in a case-insensitive "full
         * text search", effectively producing an OR clause of LIKE
         * clauses for every string-ish field in the resource being
         * queried.
         *
         * Examples:
         * - `foo` - any field containing 'foo'
         * - `foo|bar` - any field containing either 'foo' OR 'bar'
         * - `foo&bar` - some field contains 'foo' AND some field contains 'bar'
         *
         * A _filter_ can further constrain the results. The filter's
         * field name must correspond to one of the resource's
         * attributes. If it doesn't, an error will be returned
         * containing a list of the valid fields for that resource.
         *
         * The value 'null' is treated specially for [not]equal filters:
         * it returns resources on which the field isn't set. Use the
         * LIKE operator, `~`, to match a literal "null" string.
         *
         * Examples:
         * - `name=foo` - entity's _name_ matches 'foo' exactly
         * - `name~foo` - entity's _name_ contains 'foo', case-insensitive
         * - `name~foo|bar` - entity's _name_ contains either 'foo' OR 'bar', case-insensitive
         * - `name=null` - entity's _name_ isn't set
         * - `published>3 days ago` - date values can be "human time"
         *
         * Multiple full text searches and/or filters should be
         * '&'-delimited -- they are logically AND'd together.
         *
         * - `red hat|fedora&labels:type=cve|osv&published>last wednesday 17:00`
         *
         * Fields corresponding to JSON objects in the database may use a
         * ':' to delimit the column name and the object key,
         * e.g. `purl:qualifiers:type=pom`
         *
         * Any operator or special character, e.g. '|', '&', within a
         * value should be escaped by prefixing it with a backslash.
         *
         */
        q?: string;
        /**
         * EBNF grammar for the _sort_ parameter:
         * ```text
         * sort = field [ ':', order ] { ',' sort }
         * order = ( "asc" | "desc" )
         * field = (* must match the name of entity's attributes *)
         * ```
         * The optional _order_ should be one of "asc" or "desc". If
         * omitted, the order defaults to "asc".
         *
         * Each _field_ name must correspond to one of the columns of the
         * table holding the entities being queried. Those corresponding
         * to JSON objects in the database may use a ':' to delimit the
         * column name and the object key,
         * e.g. `purl:qualifiers:type:desc`
         *
         */
        sort?: string;
        /**
         * The first item to return, skipping all that come before it.
         *
         * NOTE: The order of items is defined by the API being called.
         */
        offset?: number;
        /**
         * The maximum number of entries to return.
         *
         * Zero means: no limit
         */
        limit?: number;
    };
    url: '/api/v2/vulnerability';
};

export type ListVulnerabilitiesResponses = {
    /**
     * Matching vulnerabilities
     */
    200: PaginatedResultsVulnerabilitySummary;
};

export type ListVulnerabilitiesResponse = ListVulnerabilitiesResponses[keyof ListVulnerabilitiesResponses];

export type AnalyzeData = {
    body: AnalysisRequest;
    path?: never;
    query?: never;
    url: '/api/v2/vulnerability/analyze';
};

export type AnalyzeResponses = {
    /**
     * Analyze the provided purls to search for known vulnerabilities
     */
    200: AnalysisResponse;
};

export type AnalyzeResponse = AnalyzeResponses[keyof AnalyzeResponses];

export type DeleteVulnerabilityData = {
    body?: never;
    path: {
        /**
         * ID of the vulnerability
         */
        id: string;
    };
    query?: never;
    url: '/api/v2/vulnerability/{id}';
};

export type DeleteVulnerabilityErrors = {
    /**
     * Specified vulnerability not found
     */
    404: unknown;
};

export type DeleteVulnerabilityResponses = {
    /**
     * Specified vulnerability
     */
    200: VulnerabilityDetails;
};

export type DeleteVulnerabilityResponse = DeleteVulnerabilityResponses[keyof DeleteVulnerabilityResponses];

export type GetVulnerabilityData = {
    body?: never;
    path: {
        /**
         * ID of the vulnerability
         */
        id: string;
    };
    query?: never;
    url: '/api/v2/vulnerability/{id}';
};

export type GetVulnerabilityErrors = {
    /**
     * Specified vulnerability not found
     */
    404: unknown;
};

export type GetVulnerabilityResponses = {
    /**
     * Specified vulnerability
     */
    200: VulnerabilityDetails;
};

export type GetVulnerabilityResponse = GetVulnerabilityResponses[keyof GetVulnerabilityResponses];

export type ListWeaknessesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * EBNF grammar for the _q_ parameter:
         * ```text
         * q = ( values | filter ) { '&' q }
         * values = value { '|', values }
         * filter = field, operator, values
         * operator = "=" | "!=" | "~" | "!~" | ">=" | ">" | "<=" | "<"
         * value = (* any text but escape special characters with '\' *)
         * field = (* must match an entity attribute name *)
         * ```
         * Any values in a _q_ will result in a case-insensitive "full
         * text search", effectively producing an OR clause of LIKE
         * clauses for every string-ish field in the resource being
         * queried.
         *
         * Examples:
         * - `foo` - any field containing 'foo'
         * - `foo|bar` - any field containing either 'foo' OR 'bar'
         * - `foo&bar` - some field contains 'foo' AND some field contains 'bar'
         *
         * A _filter_ can further constrain the results. The filter's
         * field name must correspond to one of the resource's
         * attributes. If it doesn't, an error will be returned
         * containing a list of the valid fields for that resource.
         *
         * The value 'null' is treated specially for [not]equal filters:
         * it returns resources on which the field isn't set. Use the
         * LIKE operator, `~`, to match a literal "null" string.
         *
         * Examples:
         * - `name=foo` - entity's _name_ matches 'foo' exactly
         * - `name~foo` - entity's _name_ contains 'foo', case-insensitive
         * - `name~foo|bar` - entity's _name_ contains either 'foo' OR 'bar', case-insensitive
         * - `name=null` - entity's _name_ isn't set
         * - `published>3 days ago` - date values can be "human time"
         *
         * Multiple full text searches and/or filters should be
         * '&'-delimited -- they are logically AND'd together.
         *
         * - `red hat|fedora&labels:type=cve|osv&published>last wednesday 17:00`
         *
         * Fields corresponding to JSON objects in the database may use a
         * ':' to delimit the column name and the object key,
         * e.g. `purl:qualifiers:type=pom`
         *
         * Any operator or special character, e.g. '|', '&', within a
         * value should be escaped by prefixing it with a backslash.
         *
         */
        q?: string;
        /**
         * EBNF grammar for the _sort_ parameter:
         * ```text
         * sort = field [ ':', order ] { ',' sort }
         * order = ( "asc" | "desc" )
         * field = (* must match the name of entity's attributes *)
         * ```
         * The optional _order_ should be one of "asc" or "desc". If
         * omitted, the order defaults to "asc".
         *
         * Each _field_ name must correspond to one of the columns of the
         * table holding the entities being queried. Those corresponding
         * to JSON objects in the database may use a ':' to delimit the
         * column name and the object key,
         * e.g. `purl:qualifiers:type:desc`
         *
         */
        sort?: string;
        /**
         * The first item to return, skipping all that come before it.
         *
         * NOTE: The order of items is defined by the API being called.
         */
        offset?: number;
        /**
         * The maximum number of entries to return.
         *
         * Zero means: no limit
         */
        limit?: number;
    };
    url: '/api/v2/weakness';
};

export type ListWeaknessesResponses = {
    /**
     * Matching weaknesses
     */
    200: PaginatedResultsLicenseSummary;
};

export type ListWeaknessesResponse = ListWeaknessesResponses[keyof ListWeaknessesResponses];

export type GetWeaknessData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/api/v2/weakness/{id}';
};

export type GetWeaknessResponses = {
    /**
     * The weakness
     */
    200: LicenseSummary;
};

export type GetWeaknessResponse = GetWeaknessResponses[keyof GetWeaknessResponses];

export type ClientOptions = {
    baseURL: `${string}://${string}` | (string & {});
};